#!/usr/bin/env python3
'''This module defines the `ARAXResultify` class whose `_resultify` method
enumerates subgraphs of a knowledge graph (KG) that match a pattern set by a
query graph (QG) and sets the `results` data attribute of the `message` object
to be a list of `Result` objects, each corresponding to one of the enumerated
subgraphs. The matching between the KG subgraphs and the QG can be forced to be
sensitive to edge direction by setting `ignore_edge_direction=false` (the
default is to ignore edge direction).

   Usage: python3 -u ARAX_resultify.py

   will run the built-in tests for ARAX_resultify.py. When testing, also be sure
   to run the `document_dsl_commands.py` script in the `code/ARAX/Documentation`
   directory since that script uses the `describe_me` method of this module.

'''

import collections
import copy
import math
import os
import sys
from typing import List, Dict, Set, Union, Iterable, cast, Optional, Tuple, DefaultDict
from ARAX_response import ARAXResponse

__author__ = 'Stephen Ramsey and Amy Glen'
__copyright__ = 'Oregon State University'
__credits__ = ['Stephen Ramsey', 'Amy Glen', 'David Koslicki', 'Eric Deutsch']
__license__ = 'MIT'
__version__ = '0.1.0'
__maintainer__ = 'Amy Glen'
__email__ = ''
__status__ = 'Prototype'


# is there a better way to import swagger_server?  Following SO posting 16981921
PACKAGE_PARENT = '../../UI/OpenAPI/python-flask-server'
sys.path.append(os.path.normpath(os.path.join(os.getcwd(), PACKAGE_PARENT)))
from openapi_server.models.edge import Edge
from openapi_server.models.node import Node
from openapi_server.models.q_edge import QEdge
from openapi_server.models.q_node import QNode
from openapi_server.models.query_graph import QueryGraph
from openapi_server.models.knowledge_graph import KnowledgeGraph
from openapi_server.models.node_binding import NodeBinding
from openapi_server.models.edge_binding import EdgeBinding
from openapi_server.models.result import Result
from openapi_server.models.analysis import Analysis


class ARAXResultify:
    ALLOWED_PARAMETERS = {'debug', 'ignore_edge_direction'}

    def __init__(self):
        self.response = None
        self.message = None
        self.parameters = None

    def describe_me(self):
        """
        Little helper function for internal use that describes the actions and what they can do
        :return:
        """
        full_description = """ Creates a list of results from the input query graph (QG) based on the the
information contained in the message knowledge graph (KG). Every subgraph
through the KG that satisfies the GQ is returned. Such use cases include:
- `resultify()` Returns all subgraphs in the knowledge graph that satisfy the
  query graph
- `resultiy(ignore_edge_direction=false)` This mode checks edge directions in
the QG to ensure that matching an edge in the KG to an edge in the QG is only
allowed if the two edges point in the same direction. The default is to not
check edge direction. For example, you may want to include results that include
relationships like `(protein)-[involved_in]->(pathway)` even though the
underlying KG only contains directional edges of the form
`(protein)<-[involved_in]-(pathway)`.  Note that this command will successfully
execute given an arbitrary query graph and knowledge graph provided by the
automated reasoning system, not just ones generated by Team ARA Expander."""
        command_definition = {
            "dsl_command": "resultify()",
            "description": full_description,
            "brief_description": "Creates a list of results consisting of subgraphs from the message knowledge graph "
                                 "that satisfy the query graph.",
            "parameters": {
                "ignore_edge_direction": {
                    "is_required": False,
                    "examples": ["true", "false"],
                    "enum": ["true", "false", "True", "False", "t", "f", "T", "F"],
                    "default": "true",
                    "type": "boolean",
                    "description": "Whether to ignore (vs. obey) edge directions in the query graph when identifying "
                                   "paths that fulfill it.",
                }
            }
        }
        return [command_definition]

    def apply(self, response: ARAXResponse, input_parameters: dict, mode: str = "ARAX") -> ARAXResponse:

        # Define a default response
        self.response = response
        self.message = response.envelope.message

        # Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        # Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response

        # Store these final parameters for convenience
        response.data['parameters'] = input_parameters
        self.parameters = input_parameters

        response.debug(f"Applying Resultifier to Message with parameters {input_parameters}")

        if not self.message.knowledge_graph:
            self.response.error(f"No message.knowledge_graph exists for resultify to create results from",
                                error_code="NoKG")
            return response

        # call _resultify
        self._resultify(mode=mode, describe=False)

        # Clean up the KG (should only contain nodes used in the results)
        self._clean_up_kg()

        # Return the response and done
        return response

    @staticmethod
    def recompute_qg_keys(response: ARAXResponse) -> ARAXResponse:
        """
        This method annotates nodes and edges in the KG with their respective qnode_keys and qedge_keys according to
        the node/edge bindings in the results. It is meant to be used on an already fully formed message (with results)
        that is being "imported", in a sense, so that ARAX can do further operations on it.
        """
        results = response.envelope.message.results
        kg = response.envelope.message.knowledge_graph
        qg = response.envelope.message.query_graph
        if not results:
            response.error(f"Cannot recompute QG keys for a message that has no results.", error_code="MissingResults")
            return response
        response.info(f"Recomputing QG keys (annotating nodes/edges in the KGs with their QG keys)")
        # First build a map of KG node/edges and their corresponding QG IDs
        kg_node_keys_to_qnode_keys = dict()
        kg_edge_keys_to_qedge_keys = dict()
        for result in results:
            for qnode_key, node_bindings in result.node_bindings.items():
                # FW: This is a hack to get reranking to work. might need to fix later
                if qnode_key not in qg.nodes:
                    for node_binding in node_bindings:
                        if node_binding.id in kg.nodes:
                            del kg.nodes[node_binding.id]
                    response.warning(f"While recomputing qnode keys found a node binding in the results without a corresponding query node. Removing the edge from the KG...")
                    continue
                for node_binding in node_bindings:
                    node_key = node_binding.id
                    if node_key not in kg_node_keys_to_qnode_keys:
                        kg_node_keys_to_qnode_keys[node_key] = set()
                    kg_node_keys_to_qnode_keys[node_key].add(qnode_key)
            for qedge_key, edge_bindings in result.analyses[0].edge_bindings.items():
                # FW: This is a hack to get reranking to work. might need to fix later
                if qedge_key not in qg.edges:
                    for edge_binding in edge_bindings:
                        if edge_binding.id in kg.edges:
                            del kg.edges[edge_binding.id]
                    response.warning(f"While recomputing qedge keys found a edge binding in the results without a corresponding query edge. Removing the edge from the KG...")
                    continue
                for edge_binding in edge_bindings:
                    edge_key = edge_binding.id
                    if edge_key not in kg_edge_keys_to_qedge_keys:
                        kg_edge_keys_to_qedge_keys[edge_key] = set()
                    kg_edge_keys_to_qedge_keys[edge_key].add(qedge_key)
        # Then go ahead and annotate the nodes/edges in the KG with their QG IDs
        for node_key, node in kg.nodes.items():
            if node_key not in kg_node_keys_to_qnode_keys:
                response.error(f"KG contains node(s) that do not appear in any results; cannot recompute their qnode_keys",
                               error_code="InvalidKG")
                return response
            node.qnode_keys = list(kg_node_keys_to_qnode_keys[node_key])
        for edge_key, edge in kg.edges.items():
            if edge_key not in kg_edge_keys_to_qedge_keys:
                response.error(f"KG contains edge(s) that do not appear in any results; cannot recompute their qedge_keys",
                               error_code="InvalidKG")
                return response
            edge.qedge_keys = list(kg_edge_keys_to_qedge_keys[edge_key])
        return response

    def _resultify(self, mode: str, describe: bool = False):
        """From a knowledge graph and a query graph (both in a Message object), extract a list of Results objects, each containing
        lists of NodeBinding and EdgeBinding objects. Add a list of Results objects to self.message.rseults.

        It is required that `self.parameters` contain the following:
            ignore_edge_direction: a parameter of type `bool` indicating whether
            the direction of an edge in the knowledge graph should be taken into
            account when matching that edge to an edge in the query graph. By
            default, this parameter is `true`. Set this parameter to false in
            order to require that an edge in a subgraph of the KG will only
            match an edge in the QG if both have the same direction (taking into
            account the source/target node mapping). Optional.

        """
        assert self.response is not None
        results = self.message.results
        if results is not None and len(results) > 0:
            self.response.info(f"Clearing previous results and computing a new set of results")
            self.message.results = []
            results = self.message.results
            self.message.n_results = 0

        message = self.message
        parameters = self.parameters

        debug_mode = parameters.get('debug', None)
        if debug_mode is not None:
            try:
                debug_mode = _parse_boolean_case_insensitive(debug_mode)
            except Exception as e:
                self.response.error(str(e))
                return

        for parameter_name in parameters.keys():
            if parameter_name == '':
                continue
            if parameter_name not in ARAXResultify.ALLOWED_PARAMETERS:
                error_string = "parameter type is not allowed in ARAXResultify: " + str(parameter_name)
                if not debug_mode:
                    self.response.error(error_string)
                    return
                else:
                    raise ValueError(error_string)

        kg = message.knowledge_graph
        # Only resultify the portion of the QG that's been expanded #1848
        qg = _filter_to_expanded_portion(message.query_graph, self.response)
        # Ignore kryptonite ("not") edges/nodes in Resultify (Expand takes care of those) #1119
        qg = _get_qg_without_kryptonite_portions(qg)

        ignore_edge_direction = parameters.get('ignore_edge_direction', None)
        if ignore_edge_direction is not None:
            try:
                ignore_edge_direction = _parse_boolean_case_insensitive(ignore_edge_direction)
            except ValueError as e:
                error_string = "parameter value is not allowed in ARAXResultify: " + str(ignore_edge_direction)
                if not debug_mode:
                    self.response.error(error_string)
                    return
                else:
                    raise e

        # Actually create results
        results = _get_results_for_kg_by_qg(kg,
                                            qg,
                                            mode,
                                            ignore_edge_direction,
                                            self.response)
        message_code = 'OK'
        code_description = 'Result list computed from KG and QG'

        message.results = results
        if len(results) == 0 and message_code == 'OK':
            message_code = 'WARNING'
            code_description = 'no results returned'
            if len(kg.nodes) == 0:
                code_description += '; empty knowledge graph'
            self.response.warning(code_description)

        message.n_results = len(results)
        message.code_description = code_description
        message.message_code = message_code

    def _clean_up_kg(self):
        self.response.debug(f"Cleaning up the KG to remove nodes not used in the results")
        results = self.message.results
        kg = self.message.knowledge_graph

        node_keys_used_in_results = {node_binding.id for result in results
                                     for node_binding_list in result.node_bindings.values()
                                     for node_binding in node_binding_list}
        cleaned_kg = KnowledgeGraph(nodes={node_key: node for node_key, node in kg.nodes.items()
                                           if node_key in node_keys_used_in_results},
                                    edges={edge_key: edge for edge_key, edge in kg.edges.items() if
                                           {edge.subject, edge.object}.issubset(node_keys_used_in_results)})
        self.message.knowledge_graph = cleaned_kg
        self.response.info(f"After cleaning, the KG contains {len(self.message.knowledge_graph.nodes)} nodes and "
                           f"{len(self.message.knowledge_graph.edges)} edges")


def _make_edge_key(node1_id: str,
                   node2_id: str) -> str:
    return node1_id + '->' + node2_id


def _is_specific_query_node(qnode_key: str, qnode: QNode):
    return (qnode_key is not None and ':' in qnode_key) or \
        (qnode.ids is not None and len(qnode.ids) > 0)


def _make_adj_maps(graph: Union[QueryGraph, KnowledgeGraph],
                   directed=True,
                   droploops=True) -> Dict[str, Dict[str, Set[str]]]:
    if directed:
        adj_map_in: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
        adj_map_out: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
    else:
        adj_map: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
    try:
        for edge in graph.edges.values():
            if droploops and edge.object == edge.subject:
                continue
            if directed:
                edge_node_key = edge.subject
                adj_map_out[edge_node_key].add(edge.object)
                edge_node_key = edge.object
                adj_map_in[edge_node_key].add(edge.subject)
            else:
                edge_node_key = edge.subject
                adj_map[edge_node_key].add(edge.object)
                edge_node_key = edge.object
                adj_map[edge_node_key].add(edge.subject)
    except KeyError:
        raise ValueError("Graph has an edge " + str(edge) + " that refers to a node ID (" + edge_node_key + ") that is not in the graph")
    if directed:
        ret_dict = {'in': adj_map_in, 'out': adj_map_out}
    else:
        ret_dict = {'both': adj_map}
    return ret_dict


def _bfs_dists(adj_map: Dict[str, Set[str]],
               start_node_key: str) -> Dict[str, Union[int, float]]:
    queue = collections.deque([start_node_key])
    distances = {node_key: math.inf for node_key in adj_map.keys()}
    distances[start_node_key] = 0
    while len(queue) > 0:
        node_key = queue.popleft()
        node_dist = distances[node_key]
        assert not math.isinf(node_dist)
        for neighb_node_key in cast(Iterable[str], adj_map[node_key]):
            if math.isinf(distances[neighb_node_key]):
                distances[neighb_node_key] = node_dist + 1
                queue.append(neighb_node_key)
    return distances


def _get_essence_node_for_qg(qg: QueryGraph) -> Optional[str]:
    adj_map = _make_adj_maps(qg, directed=False)['both']
    node_keys_list = list(adj_map.keys())
    all_nodes = set(node_keys_list)
    node_degrees = list(map(len, adj_map.values()))
    leaf_nodes = set(node_keys_list[i] for i, k in enumerate(node_degrees) if k == 1)
    is_set_nodes = set(qnode_key for qnode_key, qnode in qg.nodes.items() if qnode.is_set)
    specific_nodes = set(qnode_key for qnode_key, qnode in qg.nodes.items() if _is_specific_query_node(qnode_key, qnode))
    non_specific_nodes = all_nodes - specific_nodes
    non_specific_leaf_nodes = leaf_nodes & non_specific_nodes

    candidate_essence_nodes = non_specific_leaf_nodes - is_set_nodes
    if len(candidate_essence_nodes) == 0:
        candidate_essence_nodes = non_specific_nodes - is_set_nodes
    if len(candidate_essence_nodes) == 0:
        return None
    elif len(candidate_essence_nodes) == 1:
        return next(iter(candidate_essence_nodes))
    else:
        specific_leaf_nodes = specific_nodes & leaf_nodes
        if len(specific_leaf_nodes) == 0:
            qnode_keys_list = [qnode_key for qnode_key in qg.nodes]
            # TODO: Now that qg.nodes is a dict, don't think there's any order to it.. is this still worthwhile?
            map_node_key_to_pos: Dict[str, Union[int, float]] = {qnode_key: i for i, qnode_key in enumerate(qnode_keys_list)}
            if len(specific_nodes) == 0:
                # return the node key of the non-specific node with the rightmost position in the QG node list
                return sorted(candidate_essence_nodes,
                              key=lambda node_key: map_node_key_to_pos[node_key],
                              reverse=True)[0]
            else:
                if len(specific_nodes) == 1:
                    specific_node_key = next(iter(specific_nodes))
                    return sorted(candidate_essence_nodes,
                                  key=lambda node_key: abs(map_node_key_to_pos[node_key] -
                                                          map_node_key_to_pos[specific_node_key]),
                                  reverse=True)[0]
                else:
                    # there are at least two non-specific leaf nodes and at least two specific nodes
                    return sorted(candidate_essence_nodes,
                                  key=lambda node_key: min([abs(map_node_key_to_pos[node_key] -
                                                               map_node_key_to_pos[specific_node_key]) for
                                                           specific_node_key in specific_nodes]),
                                  reverse=True)[0]
        else:
            if len(specific_leaf_nodes) == 1:
                specific_leaf_node_key = next(iter(specific_leaf_nodes))
                map_node_key_to_pos = _bfs_dists(adj_map, specific_leaf_node_key)
            else:
                all_dist_maps_for_spec_leaf_nodes = {node_key: _bfs_dists(adj_map,
                                                                         node_key) for
                                                     node_key in specific_leaf_nodes}
                qnode_keys_list = [qnode_key for qnode_key in qg.nodes]
                map_node_key_to_pos = {qnode_key: min([dist_map[qnode_key] for dist_map in all_dist_maps_for_spec_leaf_nodes.values()]) for
                                      qnode_key in qnode_keys_list}
            return sorted(candidate_essence_nodes,
                          key=lambda node_key: map_node_key_to_pos[node_key],
                          reverse=True)[0]
    assert False


def _parse_boolean_case_insensitive(input_string:  str) -> bool:
    if input_string is None:
        raise ValueError("invalid value for input_string")
    input_string = input_string.lower()
    if input_string in {"true", "t"}:
        return True
    elif input_string in {"false", "f"}:
        return False
    else:
        raise ValueError("invalid value for input_string")


def _get_qg_without_kryptonite_portions(qg: QueryGraph) -> QueryGraph:
    """
    This function returns a version of the query graph in which kryptonite ("not") qedges and their associated qnodes
    (that aren't otherwised used) have been removed. Resultify should work off of such a version of the QG (effectively
    ignoring kryptonite portions) because handling of kryptonite qedges is done upstream in Expand (see #1119).
    """
    kryptonite_qedge_keys = {qedge_key for qedge_key, qedge in qg.edges.items() if qedge.exclude}
    normal_qedge_keys = set(qg.edges).difference(kryptonite_qedge_keys)
    qnode_keys_used_by_kryptonite_qedges = {qnode_key for qedge_key in kryptonite_qedge_keys for qnode_key in
                                            [qg.edges[qedge_key].subject, qg.edges[qedge_key].object]}
    qnode_keys_used_by_normal_qedges = {qnode_key for qedge_key in normal_qedge_keys for qnode_key in
                                        [qg.edges[qedge_key].subject, qg.edges[qedge_key].object]}
    qnode_keys_used_only_by_kryptonite_qedges = qnode_keys_used_by_kryptonite_qedges.difference(qnode_keys_used_by_normal_qedges)
    return QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items() if qnode_key not in qnode_keys_used_only_by_kryptonite_qedges},
                      edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items() if qedge_key in normal_qedge_keys})


def _filter_to_expanded_portion(qg: QueryGraph, log: ARAXResponse) -> QueryGraph:
    expanded_qedges = {qedge_key: qedge for qedge_key, qedge in qg.edges.items()
                       if hasattr(qedge, "filled") and qedge.filled}
    if not expanded_qedges:
        # If NO qedges have been marked as expanded but Resultify is being called, we'll assume this is either
        # an existing knowledge graph that was not created using Expand, or this is a single-node query.
        # In either case we should resultify the full QG.
        log.debug(f"No qedges were marked as expanded so we will resultify the entire QG")
        return qg
    else:
        # Otherwise we should only resultify the portion of the QG that's already been expanded
        expanded_qnodes = {qnode_key: qg.nodes[qnode_key] for qedge in expanded_qedges.values()
                           for qnode_key in {qedge.subject, qedge.object}}
        expanded_sub_qg = QueryGraph(edges=expanded_qedges, nodes=expanded_qnodes)
        log.debug(f"Expanded qedges are {set(expanded_qedges)}, expanded qnodes are {set(expanded_qnodes)}; "
                  f"will resultify only this sub-QG")
        return expanded_sub_qg


def _get_results_for_kg_by_qg(kg: KnowledgeGraph,              # all nodes *must* have qnode_key specified
                              qg: QueryGraph,
                              mode: str = "ARAX",
                              ignore_edge_direction: bool = True,
                              log: ARAXResponse = ARAXResponse()) -> List[Result]:

    if ignore_edge_direction is None:
        return _get_results_for_kg_by_qg(kg, qg, mode, log=log)

    kg_node_keys_without_qnode_key = [node_key for node_key, node in kg.nodes.items() if not node.qnode_keys]
    if len(kg_node_keys_without_qnode_key) > 0:
        log.error("these node IDs do not have qnode_keys set: " + str(kg_node_keys_without_qnode_key), error_code="MissingQNodeKeys")
        return []

    kg_edge_keys_without_qedge_key = [edge_key for edge_key, edge in kg.edges.items() if not edge.qedge_keys]
    if len(kg_edge_keys_without_qedge_key) > 0:
        log.error("these edges do not have qedge_keys set: " + str(kg_edge_keys_without_qedge_key), error_code="MissingQEdgeKeys")
        return []

    kg_edge_keys_by_qg_key = _get_kg_edge_keys_by_qg_key(kg)
    kg_node_keys_by_qg_key = _get_kg_node_keys_by_qg_key(kg)

    # --------------------- checking for validity of the NodeBindings list --------------
    # we require that every query graph node ID in the "values" slot of the node_bindings_map corresponds to an actual node in the QG
    qnode_keys_mapped_that_are_not_in_qg = [qnode_key for qnode_key in kg_node_keys_by_qg_key if qnode_key not in qg.nodes]
    if len(qnode_keys_mapped_that_are_not_in_qg) > 0:
        log.error("A node in the KG has a qnode_key that does not exist in the QueryGraph: " + str(qnode_keys_mapped_that_are_not_in_qg),
                  error_code="UnknownQNodeKey")
        return []

    # --------------------- checking for validity of the EdgeBindings list --------------
    # we require that every query graph edge ID in the "values" slot of the edge_bindings_map corresponds to an actual edge in the QG
    qedge_keys_mapped_that_are_not_in_qg = [qedge_key for qedge_key in kg_edge_keys_by_qg_key if qedge_key not in qg.edges]
    if len(qedge_keys_mapped_that_are_not_in_qg) > 0:
        log.error("An edge in the KG has a qedge_key that does not exist in the QueryGraph: " + str(qedge_keys_mapped_that_are_not_in_qg),
                  error_code="UnknownQEdgeKey")
        return []

    # --------------------- checking that the source ID and target ID of every edge in KG is a valid KG node ---------------------
    node_keys_for_edges_that_are_not_valid_nodes = [edge.subject for edge in kg.edges.values() if edge.subject not in kg.nodes] + \
                                                   [edge.object for edge in kg.edges.values() if edge.object not in kg.nodes]
    if len(node_keys_for_edges_that_are_not_valid_nodes) > 0:
        log.error("KG has Edges that refer to the following non-existent Nodes: " + str(node_keys_for_edges_that_are_not_valid_nodes),
                  error_code="OrphanEdges")
        return []

    # --------------------- checking that the source ID and target ID of every edge in QG is a valid QG node ---------------------
    invalid_qnode_keys_used_by_qedges = [qedge.subject for qedge in qg.edges.values() if qedge.subject not in qg.nodes] + \
                                        [qedge.object for qedge in qg.edges.values() if qedge.subject not in qg.nodes]
    if len(invalid_qnode_keys_used_by_qedges) > 0:
        log.error("QG has QEdges that refer to the following non-existent QNodes: " + str(invalid_qnode_keys_used_by_qedges),
                  error_code="OrphanQEdges")
        return []

    # --------------------- checking for consistency of edge-to-node relationships, for all edge bindings -----------
    # check that for each bound KG edge, the QG mappings of the KG edges source and target nodes are also the
    # source and target nodes of the QG edge that corresponds to the bound KG edge
    for qedge_key, kg_edge_keys_for_this_qedge_key in kg_edge_keys_by_qg_key.items():
        qg_edge = qg.edges[qedge_key]
        qg_source_node_key = qg_edge.subject
        qg_target_node_key = qg_edge.object
        for edge_key in kg_edge_keys_for_this_qedge_key:
            kg_edge = kg.edges.get(edge_key)
            kg_source_node_key = kg_edge.subject
            kg_target_node_key = kg_edge.object
            if qg_source_node_key != qg_target_node_key:
                edge_valid_in_same_direction = (kg_source_node_key in kg_node_keys_by_qg_key[qg_source_node_key] and
                                                kg_target_node_key in kg_node_keys_by_qg_key[qg_target_node_key])
                edge_valid_in_opposite_direction = (kg_source_node_key in kg_node_keys_by_qg_key[qg_target_node_key] and
                                                    kg_target_node_key in kg_node_keys_by_qg_key[qg_source_node_key])
                edge_is_valid = (edge_valid_in_same_direction or edge_valid_in_opposite_direction) if ignore_edge_direction else edge_valid_in_same_direction
                if not edge_is_valid:
                    kg_source_node = kg.nodes.get(kg_source_node_key)
                    kg_target_node = kg.nodes.get(kg_target_node_key)
                    log.error(f"Edge {edge_key} (fulfilling {qedge_key}) has node(s) that do not fulfill the "
                              f"expected qnodes ({qg_source_node_key} and {qg_target_node_key}). Edge's nodes are "
                              f"{kg_source_node_key} (qnode_keys: {kg_source_node.qnode_keys}) and "
                              f"{kg_target_node_key} (qnode_keys: {kg_target_node.qnode_keys}).", error_code="MismatchedNodes")
                    return []

    # ------------------- checking to make sure option groups in QG are valid ---------------------
    # Qedges with an optional qnode must themselves be labeled optional
    optional_qnode_keys = {qnode_key for qnode_key, qnode in qg.nodes.items() if qnode.option_group_id}
    optional_qedge_keys = {qedge_key for qedge_key, qedge in qg.edges.items() if qedge.option_group_id}
    qedge_keys_with_optional_qnode = {qedge_key for qedge_key, qedge in qg.edges.items() if {qedge.subject, qedge.object}.intersection(optional_qnode_keys)}
    qedge_keys_missing_optional_label = qedge_keys_with_optional_qnode.difference(optional_qedge_keys)
    if qedge_keys_missing_optional_label:
        log.error(f"These qedges need to be labeled optional because they link to an optional qnode: "
                  f"{qedge_keys_missing_optional_label}", error_code="MissingOptionalLabel")
        return []

    # ============= save until SAR can discuss with {EWD,DMK} whether there can be unmapped nodes in the KG =============
    # # if any node in the KG is not bound to a node in the QG, drop the KG node; redefine "kg" as the filtered KG
    # kg_node_keys_keep = {node.id for node in kg.nodes if node.id in node_bindings_map}
    # kg_nodes_keep_list = [node for node in kg.nodes if node.id in kg_node_keys_keep]
    # kg_edges_keep_list = [edge for edge in kg.edges if not (edge.subject in kg_node_keys_keep and
    #                                                         edge.object in kg_node_keys_keep)]
    # kg = KnowledgeGraph(nodes=kg_nodes_keep_list,
    #                     edges=kg_edges_keep_list)
    # ============= save until SAR can discuss with {EWD,DMK} whether there can be unmapped nodes in the KG =============

    # Our goal is to enumerate all distinct "edge-maximal" subgraphs of the KG that each "covers"
    # the QG. A subgraph of KG that "covers" the QG is one for which all of the following conditions hold:
    # (1) under the KG-to-QG node bindings map, the range of the KG subgraph's nodes is the entire set of nodes in the QG
    # (2) for any QG node that has "is_set=True", *all* KG nodes that are bound to the same QG node are in the subgraph
    # (3) every edge in the QG is "covered" by at least one edge in the KG

    results: List[Result] = []

    # Make sure the QG (the expanded portion) was fulfilled
    for qnode_key in qg.nodes:
        if not kg_node_keys_by_qg_key.get(qnode_key):
            log.debug(f"QG was not fulfilled - no results.")
            return results
    for qedge_key, qedge in qg.edges.items():
        if not _is_subclass_self_qedge(qedge) and not kg_edge_keys_by_qg_key.get(qedge_key):
            log.debug(f"QG was not fulfilled - no results.")
            return results

    subclass_clusters, child_to_parent_map = _get_subclass_clusters(kg_edge_keys_by_qg_key, kg_node_keys_by_qg_key, kg, qg, log)
    subclass_self_qedges = {qedge_key: qedge for qedge_key, qedge in qg.edges.items() if _is_subclass_self_qedge(qedge)}
    subclass_qnode_keys = set(subclass_clusters)
    log.debug(f"Subclass self-qedges are {set(subclass_self_qedges)}; qnodes with a subclass self-qedge are: {subclass_qnode_keys}")

    # Return empty result list if have empty KG
    if not kg.nodes:
        log.debug(f"KG is empty - no results.")
        return results

    # Recompute kg_node_keys_by_qg_keys so that it only contains parents (we 'collapse' children into parents)
    kg_node_keys_by_qg_key_collapsed = dict()
    for qnode_key, node_keys in kg_node_keys_by_qg_key.items():
        if qnode_key in subclass_qnode_keys:
            collapsed_node_keys = {child_to_parent_map[qnode_key][node_key] for node_key in node_keys}
            kg_node_keys_by_qg_key_collapsed[qnode_key] = collapsed_node_keys
        else:
            kg_node_keys_by_qg_key_collapsed[qnode_key] = node_keys

    # Handle case where QG contains multiple qnodes and no qedges (we'll dump everything in one result)
    edge_keys_by_node_pair = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
    if not qg.edges and len(qg.nodes) > 1:
        log.debug(f"QG contains only qnodes (no qedges); will create only one result with all qnodes.")
        result_graph = _create_new_empty_result_graph()
        result_graph["nodes"] = kg_node_keys_by_qg_key_collapsed
        final_result_graphs = [result_graph]
    else:
        # Build up some indexes for edges in the KG (by their subject/object nodes and qedge keys)
        log.debug(f"Building helper indexes for faster lookup of edges")
        edge_keys_by_subject_collapsed = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        edge_keys_by_object_collapsed = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        edge_keys_by_node_pair_collapsed = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        for edge_key, edge in kg.edges.items():
            for qedge_id in edge.qedge_keys:
                qedge = qg.edges[qedge_id]
                # Remap edges to parent concepts for qnodes where subclass answers were provided
                qnode_subj_fulfills, qnode_obj_fulfills = _get_qnodes_subj_and_obj_fulfill(edge, qedge, kg_node_keys_by_qg_key)
                edge_subject = child_to_parent_map[qnode_subj_fulfills][edge.subject] if qnode_subj_fulfills in subclass_qnode_keys else edge.subject
                edge_object = child_to_parent_map[qnode_obj_fulfills][edge.object] if qnode_obj_fulfills in subclass_qnode_keys else edge.object
                edge_keys_by_subject_collapsed[qedge_id][edge_subject].add(edge_key)
                edge_keys_by_object_collapsed[qedge_id][edge_object].add(edge_key)
                edge_keys_by_node_pair_collapsed[qedge_id][(edge_subject, edge_object)].add(edge_key)
                edge_keys_by_node_pair[qedge_id][(edge.subject, edge.object)].add(edge_key)
                if ignore_edge_direction:
                    edge_keys_by_node_pair_collapsed[qedge_id][(edge_object, edge_subject)].add(edge_key)
                    edge_keys_by_node_pair[qedge_id][(edge.object, edge.subject)].add(edge_key)

        # Create results off the "required" portion of the QG (excluding any qnodes/qedges belong to an "option group")
        # Note: Subclass self-qedges are not considered 'required' (they always have an option group specified)
        log.debug(f"Grabbing only required portion of QG")
        required_qg = QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items() if not qnode.option_group_id},
                                 edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items() if not qedge.option_group_id})
        log.debug(f"Required qnodes are {set(required_qg.nodes)}, required qedges are {set(required_qg.edges)}")
        qg_is_disconnected = _qg_is_disconnected(required_qg)
        if qg_is_disconnected:
            log.error(f"Required portion of QG is disconnected. This isn't allowed! 'Required' qnode IDs are: "
                      f"{[qnode_key for qnode_key in required_qg.nodes]}", error_code="DisconnectedQG")
            return []
        # Make sure all required qnodes/qedges are fulfilled
        unfulfilled_qnode_keys = set(required_qg.nodes).difference(kg_node_keys_by_qg_key_collapsed)
        unfulfilled_qedge_keys = set(required_qg.edges).difference(kg_edge_keys_by_qg_key)
        if unfulfilled_qnode_keys or unfulfilled_qedge_keys:
            log.debug(f"KG does not fulfill the (required portion of the) QG. Unfulfilled qnodes: {unfulfilled_qnode_keys}. "
                      f"Unfulfilled qedges: {unfulfilled_qedge_keys}.")
            return results
        log.info(f"Creating result graphs for required portion of QG")
        result_graphs_required = _create_result_graphs(required_qg, kg_node_keys_by_qg_key_collapsed,
                                                       edge_keys_by_subject_collapsed, edge_keys_by_object_collapsed,
                                                       edge_keys_by_node_pair_collapsed,
                                                       ignore_edge_direction, log)
        log.debug(f"Created {len(result_graphs_required)} required result graphs")

        # Then create results for each of the 'option groups' in the QG (including the 'required' portion with each)
        subclass_self_qedge_groups = {qedge.option_group_id for qedge_key, qedge in qg.edges.items()
                                      if _is_subclass_self_qedge(qedge)}
        option_groups_in_qg = {qedge.option_group_id for qedge in qg.edges.values()
                               if qedge.option_group_id}.difference(subclass_self_qedge_groups)
        # NOTE: We ignore subclass self-qedge option groups and instead process those in a different way
        if option_groups_in_qg:
            log.info(f"Distinct option groups detected in the QG are: {option_groups_in_qg}")
        option_group_results_dict = dict()
        for option_group_id in option_groups_in_qg:
            # Include qnodes/qedges that are either required or belong to this option group in our QG for this run
            option_group_qg = QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items()
                                                if qnode.option_group_id == option_group_id or not qnode.option_group_id},
                                         edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items()
                                                if qedge.option_group_id == option_group_id or not qedge.option_group_id})
            log.debug(f"For option group {option_group_id}, qnodes are {set(option_group_qg.nodes)}, "
                      f"qedges are {set(option_group_qg.edges)}")
            qg_is_disconnected = _qg_is_disconnected(option_group_qg)
            if qg_is_disconnected:
                log.error(f"Required + option group {option_group_id} portion of the QG is disconnected. "
                          f"This isn't allowed! 'Required'/group {option_group_id} qnode IDs are: "
                          f"{[qnode_key for qnode_key in option_group_qg.nodes]}", error_code="DisconnectedQG")
                return []
            log.info(f"Creating result graphs for option group {option_group_id}")
            result_graphs_for_option_group = _create_result_graphs(option_group_qg, kg_node_keys_by_qg_key_collapsed,
                                                                   edge_keys_by_subject_collapsed, edge_keys_by_object_collapsed,
                                                                   edge_keys_by_node_pair_collapsed,
                                                                   ignore_edge_direction, log,
                                                                   base_result_graphs=copy.deepcopy(result_graphs_required))
            log.debug(f"Created {len(result_graphs_for_option_group)} option group {option_group_id} result graphs")
            option_group_results_dict[option_group_id] = result_graphs_for_option_group

        # Organize our results for the 'required' portion of the QG by the IDs of their is_set=False nodes
        required_non_set_qnode_keys = [qnode_key for qnode_key, qnode in required_qg.nodes.items() if not qnode.is_set]
        log.debug(f"Required non-set qnodes are: {required_non_set_qnode_keys}")
        result_graphs_by_key = dict()
        for result_graph in result_graphs_required:
            result_key = _get_result_graph_key(result_graph, required_non_set_qnode_keys, log)
            result_graphs_by_key[result_key] = result_graph
        # Then merge our results for each option group ID into the appropriate "required" results
        if option_groups_in_qg:
            log.info(f"Merging option group result graphs into required result graphs with matching non-set qnodes")
        for option_group_id in option_groups_in_qg:
            for option_group_result_graph in option_group_results_dict[option_group_id]:
                result_key = _get_result_graph_key(option_group_result_graph, required_non_set_qnode_keys, log)
                corresponding_result_graph = result_graphs_by_key[result_key]
                # Merge this optional result's contents into its corresponding "required" result
                result_graphs_by_key[result_key] = _merge_optional_into_required_result_graph(option_group_result_graph, corresponding_result_graph)

        final_result_graphs = list(result_graphs_by_key.values())
        log.debug(f"There are a total of {len(final_result_graphs)} final result graphs")

    # ---------------------- Separate children from parents now that results have been formed ------------------ #
    qg_adj_map = _get_qg_adj_map_undirected(qg)
    for result_graph in final_result_graphs:
        # First add original edge subject/object (children) nodes to result and create a helper map for later use
        result_edge_keys_by_node_pair = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        for qedge_key, edge_keys in result_graph["edges"].items():
            qedge = qg.edges[qedge_key]
            for edge_key in edge_keys:
                original_edge = kg.edges[edge_key]
                # Don't add nodes arbitrarily because in rare case subj/obj can be indistinguishable...
                if not ((original_edge.subject in result_graph["nodes"][qedge.subject] and original_edge.object in result_graph["nodes"][qedge.object]) or
                        (original_edge.object in result_graph["nodes"][qedge.subject] and original_edge.subject in result_graph["nodes"][qedge.object])):
                    qnode_subj_fulfills, qnode_obj_fulfills = _get_qnodes_subj_and_obj_fulfill(original_edge, qedge, kg_node_keys_by_qg_key)
                    result_graph["nodes"][qnode_subj_fulfills].add(original_edge.subject)
                    result_graph["nodes"][qnode_obj_fulfills].add(original_edge.object)
                # Record this edge under its node pair
                node_pair_key = (original_edge.subject, original_edge.object)
                result_edge_keys_by_node_pair[qedge_key][node_pair_key].add(edge_key)
                if ignore_edge_direction:
                    node_pair_key_other_direction = (original_edge.object, original_edge.subject)
                    result_edge_keys_by_node_pair[qedge_key][node_pair_key_other_direction].add(edge_key)
        # Then go through and remove unhelpful ('dead-end') children and add in the proper subclass self-edges
        result_kg_adj_map = _get_kg_node_adj_map_by_qg_key(result_graph["nodes"], result_edge_keys_by_node_pair, qg)
        for subclass_qnode_key in subclass_qnode_keys:
            subclass_qedge_key = next(qedge_key for qedge_key, qedge in subclass_self_qedges.items()
                                      if qedge.subject == subclass_qnode_key)
            # Remove any child nodes that don't make any connections beyond the parent's connections
            qnode_neighbor_keys = qg_adj_map[subclass_qnode_key].difference({subclass_qnode_key})
            result_node_keys = result_graph["nodes"][subclass_qnode_key]
            node_keys_to_remove = set()
            for result_node_key in result_node_keys:
                parent_key = child_to_parent_map[subclass_qnode_key][result_node_key]
                node_is_child = parent_key != result_node_key
                if node_is_child:  # We'll leave parents in no matter what
                    child_is_useful = _node_in_result_is_useful(result_node_key, subclass_qnode_key, parent_key,
                                                                qnode_neighbor_keys, result_kg_adj_map)
                    if child_is_useful:
                        # Add a subclass self-edge between this child and its parent
                        node_pair_key = (result_node_key, parent_key)
                        subclass_edge_keys = edge_keys_by_node_pair[subclass_qedge_key][node_pair_key]
                        for subclass_edge_key in subclass_edge_keys:
                            result_graph["edges"][subclass_qedge_key].add(subclass_edge_key)
                    else:
                        # Mark this child for removal
                        node_keys_to_remove.add(result_node_key)

            # Actually remove the children we marked for removal
            for node_key_to_remove in node_keys_to_remove:
                result_graph["nodes"][subclass_qnode_key].remove(node_key_to_remove)

        # Remove any edges that were orphaned due to removing children (within this result)
        edges_to_remove = collections.defaultdict(set)
        node_keys_in_result = set.union(*result_graph["nodes"].values())
        for qedge_key, edge_keys in result_graph["edges"].items():
            for edge_key in edge_keys:
                edge = kg.edges[edge_key]
                if not {edge.subject, edge.object}.issubset(node_keys_in_result):
                    edges_to_remove[qedge_key].add(edge_key)
        for qedge_key, edge_keys_to_remove in edges_to_remove.items():
            result_graph["edges"][qedge_key] = result_graph["edges"][qedge_key].difference(edge_keys_to_remove)

    # ------------------ Convert the final result graphs into actual Swagger object model results ----------- #
    log.debug(f"Loading final result graphs into TRAPI object model")
    qnodes_with_multiple_ids = {qnode_key for qnode_key, qnode in qg.nodes.items()
                                if qnode.ids and len(qnode.ids) > 1}

    resource_id = "infores:arax" if mode == "ARAX" else "infores:rtx-kg2"
    results = []
    for result_graph in final_result_graphs:
        node_bindings = dict()
        for qnode_key, node_keys in result_graph['nodes'].items():
            node_bindings[qnode_key] = [NodeBinding(id=node_key,
                                                    query_id=_get_query_id(node_key, kg.nodes[node_key], qnode_key,
                                                                           qnodes_with_multiple_ids))
                                        for node_key in node_keys]
        edge_bindings = dict()
        for qedge_key, edge_keys in result_graph['edges'].items():
            edge_bindings[qedge_key] = [EdgeBinding(id=edge_key) for edge_key in edge_keys]
        result = Result(node_bindings=node_bindings, analyses=[Analysis(resource_id=resource_id,
                                                                        edge_bindings=edge_bindings)])

        # Fill out the essence for the result
        essence_qnode_key = _get_essence_node_for_qg(qg)
        essence_qnode = qg.nodes.get(essence_qnode_key)
        essence_kg_node_key_set = result_graph['nodes'].get(essence_qnode_key, set())
        if len(essence_kg_node_key_set) == 0:
            result.essence = cast(str, None)
            result.essence_category = cast(str, None)
        else:
            if len(essence_kg_node_key_set) == 1:
                essence_kg_node_key = next(iter(essence_kg_node_key_set))
            else:
                # Use parent concepts as essence, if available
                if essence_qnode_key in child_to_parent_map:
                    parent_keys = {child_to_parent_map[essence_qnode_key][node_key] for node_key in essence_kg_node_key_set}
                    if len(parent_keys) == 1:
                        essence_kg_node_key = next(iter(parent_keys))
                    elif not essence_qnode.is_set:
                        log.error(f"Result contains more than one 'parent' concept fulfilling the essence qnode "
                                  f"({essence_qnode_key}, which has is_set=False). This shouldn't be possible!",
                                  error_code="SubclassProblem")
                        essence_kg_node_key = next(iter(parent_keys))
                    else:
                        log.warning(f"A result has multiple parent concepts fulfilling the essence qnode {essence_qnode_key}; "
                                    f"will arbitrarily select one to use as the essence for this result")
                        essence_kg_node_key = next(iter(parent_keys))
                # Otherwise we'll have to just pick one KG node to use as essence
                else:
                    log.warning(f"A result has multiple KG nodes fulfilling the essence Qnode {essence_qnode_key}; "
                                f"will arbitrarily select one to use as the essence for this result {result}")
                    essence_kg_node_key = next(iter(essence_kg_node_key_set))

            essence_kg_node = kg.nodes[essence_kg_node_key]
            result.essence = essence_kg_node.name
            if result.essence is None:
                result.essence = essence_kg_node_key
            assert result.essence is not None
            if essence_kg_node.attributes:
                symbol_attributes = [attribute for attribute in essence_kg_node.attributes if attribute.original_attribute_name == "symbol"]
                symbol_attribute = symbol_attributes[0] if symbol_attributes else None
                if symbol_attribute and symbol_attribute.value is not None:
                    result.essence += " (" + str(symbol_attribute.value) + ")"
            result.essence_category = str(essence_qnode.categories) if essence_qnode else None

        # Programmatically generating an informative description for each result
        # seems difficult, but having something non-None is required by the
        # database.  Just put in a placeholder for now, as is done by the
        # QueryGraphReasoner
        result.description = "No description available"  # see issue 642

        results.append(result)

    log.info(f"Resultify created {len(results)} results")
    log.total_results_count = len(results)
    return results


def _node_in_result_is_useful(node_key: str, qnode_key: str, parent_key: str, qnode_neighbor_keys: Set[str],
                              result_kg_adj_map: Dict[str, Dict[str, Dict[str, Set[str]]]]) -> bool:
    """
    This function determines whether the given node (node_key, which fulfills qnode_key), adds information to a result
    beyond that provided by its parent (parent_key). Nodes that do not can be considered 'dead ends'. Dead end
    child nodes are somewhat similar to dead-end intermediate nodes when is_set=True; if they don't link through on a
    path that matches the full QG, they're dead ends. The difference is that together a parent + child need to link
    through, instead of a single node.
    """
    has_same_neighbors = []
    has_additional_neighbors = []
    for qnode_neighbor_key in qnode_neighbor_keys:
        parent_neighbors = result_kg_adj_map[qnode_key][parent_key][qnode_neighbor_key]
        own_neighbors = result_kg_adj_map[qnode_key][node_key][qnode_neighbor_key]
        if own_neighbors.difference(parent_neighbors):
            has_additional_neighbors.append(True)
        else:
            has_additional_neighbors.append(False)
        if own_neighbors == parent_neighbors:
            has_same_neighbors.append(True)
        else:
            has_same_neighbors.append(False)
    return True if any(has_additional_neighbors) or all(has_same_neighbors) else False


def _get_result_graph_counts(result_graph):
    qnode_counts = {qnode_key: len(nodes) for qnode_key, nodes in result_graph["nodes"].items()}
    qedge_counts = {qedge_key: len(edges) for qedge_key, edges in result_graph["edges"].items()}
    return f"nodes {qnode_counts}, edges {qedge_counts}"


def _qg_is_disconnected(qg: QueryGraph) -> bool:
    qnode_keys_examined = {next(qnode_key for qnode_key in qg.nodes)} if qg.nodes else set()  # Start with any qnode
    qnode_keys_remaining = set(qg.nodes).difference(qnode_keys_examined)
    # Repeatedly look for a qnode connected to at least one of the already examined qnodes
    connected_qnode_key, _ = _find_qnode_connected_to_sub_qg(qnode_keys_examined, qnode_keys_remaining, qg)
    while connected_qnode_key and qnode_keys_remaining:
        qnode_keys_remaining.remove(connected_qnode_key)
        qnode_keys_examined.add(connected_qnode_key)
        connected_qnode_key, _ = _find_qnode_connected_to_sub_qg(qnode_keys_examined, qnode_keys_remaining, qg)
    # The QG must be disconnected if there are qnodes remaining that are not connected to any of our examined ones
    return True if not connected_qnode_key and qnode_keys_remaining else False


def _merge_optional_into_required_result_graph(optional_result_graph: Dict[str, Dict[str, Set[str]]],
                                               required_result_graph: Dict[str, Dict[str, Set[str]]]) -> Dict[str, Dict[str, Set[str]]]:
    # Start with the required result graph and then add in any nodes/edges from the optional graph as appropriate
    merged_result_graph = _copy_result_graph(required_result_graph)
    for qnode_key, optional_kg_node_keys in optional_result_graph["nodes"].items():
        if qnode_key in required_result_graph["nodes"]:
            merged_result_graph["nodes"][qnode_key] = required_result_graph["nodes"][qnode_key].union(optional_kg_node_keys)
        else:
            merged_result_graph["nodes"][qnode_key] = optional_kg_node_keys
    for qedge_key, optional_kg_edge_keys in optional_result_graph["edges"].items():
        if qedge_key in required_result_graph["edges"]:
            merged_result_graph["edges"][qedge_key] = required_result_graph["edges"][qedge_key].union(optional_kg_edge_keys)
        else:
            merged_result_graph["edges"][qedge_key] = optional_kg_edge_keys
    return merged_result_graph


def _get_qnodes_subj_and_obj_fulfill(edge: Edge, qedge: QEdge, kg_node_keys_by_qg_key: Dict[str, Set[str]]) -> Tuple[str, str]:
    if edge.subject in kg_node_keys_by_qg_key[qedge.subject] and edge.object in kg_node_keys_by_qg_key[qedge.object]:
        return qedge.subject, qedge.object
    else:
        return qedge.object, qedge.subject


def _get_result_graph_key(result_graph: Dict[str, Dict[str, Set[str]]], qnodes_to_merge_on: List[str],
                          log: ARAXResponse) -> str:
    """
    Result graph keys are defined such that result graphs with the same key should be merged. The overall result graph
    key is a concatenation of one 'merge key' per each qnode to merge on, which generally should be each is_set=False,
    required qnode. Each result should only have one node fulfilling a required, is_set=False qnode, so the ID for
    that node is used as the merge key. Note that for subclass/query_id handling, we map children to parents BEFORE
    resultifying, and undo that mapping afterwards, which means we don't need a special case here to handle that.
    (Merge keys are automatically parents for such subclass qnodes because of this pre-mapping that we do.)
    """
    qnodes_to_merge_on.sort()
    merge_keys = []
    for qnode_key in qnodes_to_merge_on:
        result_nodes = list(result_graph["nodes"][qnode_key])
        if len(result_nodes) > 1:
            log.error(f"Do not know what merge key to use when more than one node is fulfilling a non-set"
                      f" qnode. Nodes {result_nodes} are fulfilling {qnode_key} in a single result. "
                      f"Result graph is {result_graph}", error_code="MergeKeyError")
            merge_key = "?"
        else:
            # There must only be one node fulfilling this qnode
            merge_key = result_nodes[0]
        merge_keys.append(merge_key)
    result_graph_key = "--".join(merge_keys)
    return result_graph_key


def _get_kg_node_keys_by_qg_key(knowledge_graph: KnowledgeGraph) -> Dict[str, Set[str]]:
    node_keys_by_qg_key = dict()
    for node_key, node in knowledge_graph.nodes.items():
        if node.qnode_keys:
            for qnode_key in node.qnode_keys:
                if qnode_key not in node_keys_by_qg_key:
                    node_keys_by_qg_key[qnode_key] = set()
                node_keys_by_qg_key[qnode_key].add(node_key)
    return node_keys_by_qg_key


def _get_kg_edge_keys_by_qg_key(knowledge_graph: KnowledgeGraph) -> Dict[str, Set[str]]:
    edge_keys_by_qg_key = dict()
    for edge_key, edge in knowledge_graph.edges.items():
        if edge.qedge_keys:
            for qedge_key in edge.qedge_keys:
                if qedge_key not in edge_keys_by_qg_key:
                    edge_keys_by_qg_key[qedge_key] = set()
                edge_keys_by_qg_key[qedge_key].add(edge_key)
    return edge_keys_by_qg_key


def _get_connected_qnode_keys(qnode_key: str, query_graph: QueryGraph) -> Set[str]:
    qnode_keys_used_on_same_qedges = set()
    for qedge in query_graph.edges.values():
        if qnode_key in {qedge.subject, qedge.object}:
            qnode_keys_used_on_same_qedges.add(qedge.subject)
            qnode_keys_used_on_same_qedges.add(qedge.object)
    return qnode_keys_used_on_same_qedges.difference({qnode_key})


def _create_new_empty_result_graph() -> Dict[str, Dict[str, Set[str]]]:
    empty_result_graph = {'nodes': collections.defaultdict(set),
                          'edges': collections.defaultdict(set),
                          'parents': collections.defaultdict(str)}
    return empty_result_graph


def _copy_result_graph(result_graph: Dict[str, Dict[str, Set[str]]]) -> Dict[str, Dict[str, Set[str]]]:
    result_graph_copy = copy.deepcopy(result_graph)
    return result_graph_copy


def _get_parallel_qedge_keys(input_qedge: QEdge, query_graph: QueryGraph) -> Set[str]:
    input_qedge_node_keys = {input_qedge.subject, input_qedge.object}
    parallel_qedge_keys = {qedge_key for qedge_key, qedge in query_graph.edges.items() if {qedge.subject, qedge.object} == input_qedge_node_keys}
    return parallel_qedge_keys


def _get_query_id(node_key: str, node: Node, qnode_key: str, qnode_keys_with_multiple_ids: Set[str]) -> Optional[str]:
    # TODO: Should this really be looking at child to parent map, instead of node's query_ids?
    if qnode_key in qnode_keys_with_multiple_ids:
        if hasattr(node, "query_ids") and node.query_ids:
            query_id = _get_best_parent_id(node.query_ids)  # TODO: How should multiple query_ids be handled?? Separate results? Brought up in #1871
            return query_id if query_id != node_key else None
        else:
            return None
    else:
        return None


def _get_kg_node_adj_map_by_qg_key(kg_node_keys_by_qg_key: Dict[str, Set[str]],
                                   edge_keys_by_node_pair: DefaultDict[str, DefaultDict[Tuple[str], set]],
                                   qg: QueryGraph) -> Dict[str, Dict[str, Dict[str, Set[str]]]]:
    # Returned dict looks like {'n00': {'UMLS:11234': {'n01': {UniProtKB:122}}}}
    # First initiate the overall structure of our (QG-organized) adjacency map
    kg_node_to_node_map = {qnode_key: dict() for qnode_key in kg_node_keys_by_qg_key}
    for qnode_key in qg.nodes:
        node_keys_set = kg_node_keys_by_qg_key[qnode_key]
        connected_qnode_keys = _get_connected_qnode_keys(qnode_key, qg)
        for node_key in node_keys_set:
            kg_node_to_node_map[qnode_key][node_key] = {connected_qnode_key: set() for connected_qnode_key in connected_qnode_keys}

    # Create a record of which qedge IDs are fulfilled between which node pairs
    node_pair_to_qedge_key_map = collections.defaultdict(set)
    for qedge_key, node_pairs_dict in edge_keys_by_node_pair.items():
        for node_pair_key in node_pairs_dict:
            node_pair_to_qedge_key_map[node_pair_key].add(qedge_key)

    # Fill out which KG nodes are connected to which
    for qedge_key, node_pairs_dict in edge_keys_by_node_pair.items():
        # Note: KG may contain some qedge IDs not in this version of the QG due to option group handling
        if qedge_key in qg.edges:
            qedge = qg.edges[qedge_key]
            # Make sure ALL qedges between this edge's two nodes have been fulfilled before marking them as 'connected'
            parallel_qedge_keys = _get_parallel_qedge_keys(qedge, qg)
            for node_pair_key in node_pairs_dict:
                if parallel_qedge_keys.issubset(node_pair_to_qedge_key_map[node_pair_key]):
                    node_a = node_pair_key[0]
                    node_b = node_pair_key[1]
                    qnode_key_1 = qedge.subject
                    qnode_key_2 = qedge.object
                    if node_a in kg_node_keys_by_qg_key[qnode_key_1] and node_b in kg_node_keys_by_qg_key[qnode_key_2]:
                        kg_node_to_node_map[qnode_key_1][node_a][qnode_key_2].add(node_b)
                        kg_node_to_node_map[qnode_key_2][node_b][qnode_key_1].add(node_a)
                    if node_a in kg_node_keys_by_qg_key[qnode_key_2] and node_b in kg_node_keys_by_qg_key[qnode_key_1]:
                        kg_node_to_node_map[qnode_key_2][node_a][qnode_key_1].add(node_b)
                        kg_node_to_node_map[qnode_key_1][node_b][qnode_key_2].add(node_a)

    return kg_node_to_node_map


def _result_graph_is_fulfilled(result_graph: Dict[str, Dict[str, Set[str]]], query_graph: QueryGraph,
                               nodes_only: bool = False) -> bool:
    for qnode_key in query_graph.nodes:
        if not result_graph['nodes'].get(qnode_key):
            return False
    if not nodes_only:
        for qedge_key in query_graph.edges:
            if not result_graph['edges'].get(qedge_key):
                return False
    return True


def _is_subclass_self_qedge(qedge: QEdge) -> bool:
    return qedge.subject == qedge.object and qedge.predicates == ["biolink:subclass_of"]


def _get_all_adjacent_nodes(kg_node_keys: Set[str], start_qnode_key: str, target_qnode_key: str,
                            kg_node_adj_map_by_qg_key: Dict[str, Dict[str, Dict[str, Set[str]]]]) -> Set[str]:
    """
    This function returns all nodes adjacent to a set of nodes (kg_node_keys) that fulfill the target_qnode_key. The
    start_qnode_key is the qnode ID that the set of input nodes fulfill. Being adjacent to the set of nodes means that
    the node is connected to ANY of the individual input nodes in the set (not ALL).
    """
    connections = [kg_node_adj_map_by_qg_key[start_qnode_key][kg_node_key][target_qnode_key] for kg_node_key in kg_node_keys]
    return {node_key for node_key_set in connections for node_key in node_key_set}


def _find_qnode_connected_to_sub_qg(qnode_keys_to_connect_to: Set[str], qnode_keys_to_choose_from: Set[str],
                                    qg: QueryGraph) -> Tuple[str, Set[str]]:
    """
    This function selects a qnode ID from the qnode_keys_to_choose_from that connects to one or more of the qnode IDs
    in the qnode_keys_to_connect_to (which is generally a sub-graph of the QG). It also returns the IDs
    of the connection points (all qnode ID(s) in qnode_keys_to_connect_to that the chosen node connects to).
    """
    for qnode_key_option in qnode_keys_to_choose_from:
        all_qedges_using_qnode = [qedge for qedge in qg.edges.values() if qnode_key_option in {qedge.subject, qedge.object}]
        all_connected_qnode_keys = {qnode_key for qedge in all_qedges_using_qnode for qnode_key in
                                    {qedge.subject, qedge.object}}.difference({qnode_key_option})
        subgraph_connections = qnode_keys_to_connect_to.intersection(all_connected_qnode_keys)
        if subgraph_connections:
            return qnode_key_option, subgraph_connections
    return "", set()


def _get_qg_adj_map_undirected(qg: QueryGraph) -> Dict[str, Set[str]]:
    """
    This function creates a node adjacency map for a given query graph. Example: {"n0": {"n1"}, "n1": {"n0"}}
    """
    qg_adj_map = dict()
    for qnode_key in qg.nodes:
        connected_qedges = [qedge for qedge in qg.edges.values() if qnode_key in {qedge.subject, qedge.object}]
        connected_qnode_keys = set()
        for connected_qedge in connected_qedges:
            # Note: The below purposefully allows other_qnode_key to be equal to qnode_key for self-qedges only
            other_qnode_key = connected_qedge.subject if connected_qedge.subject != qnode_key else connected_qedge.object
            connected_qnode_keys.add(other_qnode_key)
        qg_adj_map[qnode_key] = connected_qnode_keys
    return qg_adj_map


def _extract_sub_qg_adj_map(qg_adj_map: Dict[str, Set[str]], allowed_qnode_keys: Set[str]) -> Dict[str, Set[str]]:
    """
    This function extracts the node adjacency info for a "subgraph" of the query graph (represented by
    allowed_qnode_keys). Example of qg_adj_map: {"n0": {"n1"}, "n1": {"n0"}}
    """
    return {qnode_key: neighbor_qnode_keys.intersection(allowed_qnode_keys)
            for qnode_key, neighbor_qnode_keys in qg_adj_map.items() if qnode_key in allowed_qnode_keys}


def _get_subclass_clusters(kg_edge_keys_by_qg_key: Dict[str, Set[str]], kg_node_keys_by_qg_key: Dict[str, Set[str]],
                           kg: KnowledgeGraph, qg: QueryGraph,
                           log: ARAXResponse) -> Tuple[Dict[str, Dict[str, Set[str]]], Dict[str, Dict[str, str]]]:
    """
    Create two helper maps: one that maps parent IDs to their set of child IDs, and another that maps child IDs to
    their parent IDs. Parent-child relationships are determined based on the edges in the KG fulfilling any subclass
    self-qedges that Expand added to the QG.
    """
    subclass_self_qedges = {qedge_key for qedge_key, qedge in qg.edges.items()
                            if _is_subclass_self_qedge(qedge)}
    subclass_self_qnodes = {qg.edges[qedge_key].subject for qedge_key in subclass_self_qedges}
    subclass_clusters = {subclass_qnode_key: dict() for subclass_qnode_key in subclass_self_qnodes}
    child_to_parents_map = {subclass_qnode_key: collections.defaultdict(set) for subclass_qnode_key in subclass_self_qnodes}
    # Record parent/child mappings based on the subclass self-edges in the KG
    for subclass_qedge_key in subclass_self_qedges:
        subclass_qnode_key = qg.edges[subclass_qedge_key].subject
        for edge_key in kg_edge_keys_by_qg_key.get(subclass_qedge_key, set()):
            edge = kg.edges[edge_key]
            parent_id = edge.object
            child_id = edge.subject
            if parent_id not in subclass_clusters[subclass_qnode_key]:
                subclass_clusters[subclass_qnode_key][parent_id] = {parent_id}
            subclass_clusters[subclass_qnode_key][parent_id].add(child_id)
            child_to_parents_map[subclass_qnode_key][child_id].add(parent_id)
            child_to_parents_map[subclass_qnode_key][parent_id].add(parent_id)  # It's handy to list parents as parent of themselves
    # Also list any parents that may not have subclass self-edges as parents of themselves
    for subclass_qnode_key in subclass_self_qnodes:
        node_keys_for_qnode = kg_node_keys_by_qg_key[subclass_qnode_key]
        node_keys_with_subclass_edge = set(child_to_parents_map[subclass_qnode_key])
        node_keys_with_no_subclass_edge = node_keys_for_qnode.difference(node_keys_with_subclass_edge)
        for node_key in node_keys_with_no_subclass_edge:
            # Otherwise we'll record this node as its own parent
            # Note: Such nodes won't always appear in the QG because they can be returned for unpinned nodes
            child_to_parents_map[subclass_qnode_key][node_key] = {node_key}

    # Keep only one parent per child per qnode key; system/TRAPI isn't set up to handle multiple yet
    child_to_parent_map = {subclass_qnode_key: dict() for subclass_qnode_key in subclass_self_qnodes}
    for qnode_key, mappings in child_to_parents_map.items():
        for child_id, parent_ids in mappings.items():
            best_parent_id = _get_best_parent_id(parent_ids)
            child_to_parent_map[qnode_key][child_id] = best_parent_id

    return subclass_clusters, child_to_parent_map


def _get_best_parent_id(parent_ids: Iterable[str]) -> str:
    # TODO: TRAPI and our system elsewhere isn't set up to handle multiple query IDs per node... change eventually?
    return list(sorted(list(parent_ids)))[0]


def _clean_up_dead_ends(result_graph: Dict[str, Dict[str, Set[str]]],
                        sub_qg_adj_map: Dict[str, Set[str]],
                        kg_node_adj_map_by_qg_key: Dict[str, Dict[str, Dict[str, Set[str]]]],
                        log: ARAXResponse) -> Dict[str, Dict[str, Set[str]]]:
    """
    This function iteratively removes "dead ends" from a result graph until no more dead ends can be found. Dead ends
    can be thought of as intermediate nodes (typically for is_set=True qnodes) that connect to only a subset of the
    nodes they should be connected to according to the query graph. Only the part of the result graph that has been
    "fulfilled" so far during the result construction process is evaluated here: the sub_qg_adj_map must contain only
    info for qnodes fulfilled thus far.
    """
    fulfilled_qnode_keys = set(sub_qg_adj_map)
    found_dead_ends = True
    while found_dead_ends:
        found_dead_ends = False
        nodes_to_remove = dict()
        # Go through each qnode "role" in our result graph, and check the nodes corresponding to that qnode
        for qnode_key in fulfilled_qnode_keys:
            corresponding_node_keys = result_graph["nodes"][qnode_key]
            required_neighbor_qnode_keys = sub_qg_adj_map[qnode_key]
            # Make sure each node for this qnode ID is connected to at LEAST one node fulfilling each neighbor qnode ID
            for corresponding_node_key in corresponding_node_keys:
                for neighbor_qnode_key in required_neighbor_qnode_keys:
                    # Look for at least one node in the result graph in this neighbor spot that this node is linked to
                    neighbors_in_kg = kg_node_adj_map_by_qg_key[qnode_key][corresponding_node_key][neighbor_qnode_key]
                    if not neighbors_in_kg.intersection(result_graph["nodes"][neighbor_qnode_key]):
                        # Mark this node for removal from this result graph since it's lacking a neighbor here
                        found_dead_ends = True
                        if qnode_key not in nodes_to_remove:
                            nodes_to_remove[qnode_key] = set()
                        nodes_to_remove[qnode_key].add(corresponding_node_key)
        # Actually go through and remove our nodes marked for removal
        for qnode_key, node_keys in nodes_to_remove.items():
            result_graph["nodes"][qnode_key] = result_graph["nodes"][qnode_key].difference(node_keys)
    return result_graph


def _create_result_graphs(qg: QueryGraph,
                          kg_node_keys_by_qg_key: Dict[str, Set[str]],
                          edge_keys_by_subject: DefaultDict[str, DefaultDict[str, set]],
                          edge_keys_by_object: DefaultDict[str, DefaultDict[str, set]],
                          edge_keys_by_node_pair: DefaultDict[str, DefaultDict[Tuple[str], set]],
                          ignore_edge_direction: bool = True,
                          log: ARAXResponse = ARAXResponse(),
                          base_result_graphs: Optional[List[dict]] = None) -> List[dict]:
    kg_node_adj_map_by_qg_key = _get_kg_node_adj_map_by_qg_key(kg_node_keys_by_qg_key, edge_keys_by_node_pair, qg)
    qg_adj_map = _get_qg_adj_map_undirected(qg)

    # Iteratively construct "result graphs" (initially containing only nodes, not edges) by walking through all qnodes
    log.debug(f"Constructing result graphs qnode by qnode")
    if base_result_graphs:
        # We'll build off of the 'base' result graphs rather than start anew (saves time for option group processing)
        result_graphs = base_result_graphs
        qnode_keys_already_handled = set(result_graphs[0]["nodes"])
        qnode_keys_remaining = set(qg.nodes).difference(qnode_keys_already_handled)
    else:
        result_graphs = []
        qnode_keys_already_handled = set()
        qnode_keys_remaining = set(qg.nodes)
    log.debug(f"Qnode keys already handled are: {qnode_keys_already_handled}")
    while qnode_keys_remaining:
        # Start with a random qnode if this is our first iteration
        if not qnode_keys_already_handled:
            current_qnode_key = list(qnode_keys_remaining)[0]
            prior_qnode_connections = set()
        # Otherwise find a yet unhandled qnode ID that connects somehow to the part of the QG we've already handled
        else:
            current_qnode_key, prior_qnode_connections = _find_qnode_connected_to_sub_qg(qnode_keys_already_handled, qnode_keys_remaining, qg)
            log.debug(f"Next qnode chosen is: {current_qnode_key}")
        current_qnode = qg.nodes[current_qnode_key]

        # Initialize our result graphs if this is our first iteration
        if not result_graphs:
            log.debug(f"Initiating result graphs with nodes for {current_qnode_key} (is_set={current_qnode.is_set})")
            all_node_keys_in_kg_for_this_qnode_key = kg_node_keys_by_qg_key.get(current_qnode_key)
            # We'll start with one result graph with ALL corresponding nodes in the KG in this spot if is_set=True
            if current_qnode.is_set:
                log.debug(f"Starting with one result graph because is_set=True for {current_qnode_key}")
                new_result_graph = _create_new_empty_result_graph()
                new_result_graph["nodes"][current_qnode_key] = all_node_keys_in_kg_for_this_qnode_key  # Parents included already
                result_graphs.append(new_result_graph)
            # Otherwise, we'll start with a result graph for EACH corresponding node in the KG
            else:
                log.debug(f'Starting with a result graph for each {current_qnode_key} node')
                for node_key in all_node_keys_in_kg_for_this_qnode_key:
                    new_result_graph = _create_new_empty_result_graph()
                    new_result_graph["nodes"][current_qnode_key] = {node_key}
                    result_graphs.append(new_result_graph)
        # Otherwise fan out our existing result graphs, filling out this qnode spot in them based on prior contents
        else:
            log.debug(f"Adding a layer to each result graph for qnode {current_qnode_key} (is_set={current_qnode.is_set})")
            new_result_graphs = []
            sub_qg_adj_map = _extract_sub_qg_adj_map(qg_adj_map, qnode_keys_already_handled.union({current_qnode_key}))
            for result_graph in result_graphs:
                # Figure out which KG nodes could fulfill the current qnode in this result
                prior_qnodes_kg_nodes = {prior_qnode_key: result_graph["nodes"][prior_qnode_key] for prior_qnode_key in prior_qnode_connections}
                current_kg_node_possibilities = [_get_all_adjacent_nodes(corresponding_kg_nodes, prior_qnode_key, current_qnode_key, kg_node_adj_map_by_qg_key)
                                                 for prior_qnode_key, corresponding_kg_nodes in prior_qnodes_kg_nodes.items()]
                # Only keep connections that have links to KG nodes in ALL prior connected qnode roles
                final_connected_kg_nodes = set.intersection(*current_kg_node_possibilities)

                # Fan out or add to result graphs as appropriate
                if final_connected_kg_nodes:
                    if current_qnode.is_set:
                        # Replace this result graph with a new one with all valid connections listed under this qnode
                        new_result_graph = _copy_result_graph(result_graph)
                        new_result_graph["nodes"][current_qnode_key] = final_connected_kg_nodes
                        pruned_result_graph = _clean_up_dead_ends(result_graph=new_result_graph,
                                                                  sub_qg_adj_map=sub_qg_adj_map,
                                                                  kg_node_adj_map_by_qg_key=kg_node_adj_map_by_qg_key,
                                                                  log=log)
                        new_result_graphs.append(pruned_result_graph)
                    else:
                        # Create a new result graph for each new valid connected node
                        for connected_node_key in final_connected_kg_nodes:
                            new_result_graph = _copy_result_graph(result_graph)
                            new_result_graph["nodes"][current_qnode_key] = {connected_node_key}
                            pruned_result_graph = _clean_up_dead_ends(result_graph=new_result_graph,
                                                                      sub_qg_adj_map=sub_qg_adj_map,
                                                                      kg_node_adj_map_by_qg_key=kg_node_adj_map_by_qg_key,
                                                                      log=log)
                            new_result_graphs.append(pruned_result_graph)

            result_graphs = new_result_graphs
        log.debug(f"Current count of result graphs is {len(result_graphs)}")

        # Update our records about which qnodes we've already processed
        qnode_keys_remaining.remove(current_qnode_key)
        qnode_keys_already_handled.add(current_qnode_key)
    log.debug(f"Done assigning nodes to result graphs.")

    # Then add edges to our result graphs as appropriate (note, we DON'T add subclass self-qedges for now)
    log.debug(f"Adding edges to result graphs")
    for result_graph in result_graphs:
        for qedge_key, qedge in qg.edges.items():
            qedge_source_node_ids = result_graph['nodes'][qedge.subject]
            qedge_target_node_ids = result_graph['nodes'][qedge.object]
            # Pick the more efficient method for edge-finding depending on the number of nodes for this result/qedge
            if len(qedge_source_node_ids) < 10 or len(qedge_target_node_ids) < 10:
                possible_node_pairs = {(node_1, node_2) for node_1 in qedge_source_node_ids
                                       for node_2 in qedge_target_node_ids}
                for node_pair in possible_node_pairs:
                    ids_of_matching_edges = edge_keys_by_node_pair[qedge_key].get(node_pair, set())
                    result_graph['edges'][qedge_key].update(ids_of_matching_edges)
            else:
                # This technique is more efficient when there are large numbers of both subject and object nodes
                edges_with_matching_subject = {edge_key for source_node in qedge_source_node_ids
                                               for edge_key in edge_keys_by_subject[qedge_key][source_node]}
                edges_with_matching_object = {edge_key for target_node in qedge_target_node_ids
                                              for edge_key in edge_keys_by_object[qedge_key][target_node]}
                result_graph['edges'][qedge_key] = edges_with_matching_subject.intersection(edges_with_matching_object)
                if ignore_edge_direction:
                    edges_with_reverse_subject = {edge_key for target_node in qedge_target_node_ids
                                                  for edge_key in edge_keys_by_subject[qedge_key][target_node]}
                    edges_with_reverse_object = {edge_key for source_node in qedge_source_node_ids
                                                 for edge_key in edge_keys_by_object[qedge_key][source_node]}
                    result_graph['edges'][qedge_key].update(edges_with_reverse_subject.intersection(edges_with_reverse_object))

    # Filter out any results for which not every qnode/qedge is fulfilled (with the exception of subclass self-qedges)
    final_result_graphs = [result_graph for result_graph in result_graphs if _result_graph_is_fulfilled(result_graph, qg)]
    log.debug(f"After pruning out result graphs missing edges, there are {len(final_result_graphs)} result graphs")
    return final_result_graphs
