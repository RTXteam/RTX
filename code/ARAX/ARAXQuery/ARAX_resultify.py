#!/usr/bin/env python3
'''This module defines the `ARAXResultify` class whose `_resultify` method
enumerates subgraphs of a knowledge graph (KG) that match a pattern set by a
query graph (QG) and sets the `results` data attribute of the `message` object
to be a list of `Result` objects, each corresponding to one of the enumerated
subgraphs. The matching between the KG subgraphs and the QG can be forced to be
sensitive to edge direction by setting `ignore_edge_direction=false` (the
default is to ignore edge direction).

   Usage: python3 -u ARAX_resultify.py

   will run the built-in tests for ARAX_resultify.py. When testing, also be sure
   to run the `document_dsl_commands.py` script in the `code/ARAX/Documentation`
   directory since that script uses the `describe_me` method of this module.

'''

import collections
import copy
import math
import os
import sys
from typing import List, Dict, Set, Union, Iterable, cast, Optional, Tuple, DefaultDict
from ARAX_response import ARAXResponse

__author__ = 'Stephen Ramsey and Amy Glen'
__copyright__ = 'Oregon State University'
__credits__ = ['Stephen Ramsey', 'Amy Glen', 'David Koslicki', 'Eric Deutsch']
__license__ = 'MIT'
__version__ = '0.1.0'
__maintainer__ = 'Amy Glen'
__email__ = ''
__status__ = 'Prototype'


# is there a better way to import swagger_server?  Following SO posting 16981921
PACKAGE_PARENT = '../../UI/OpenAPI/python-flask-server'
sys.path.append(os.path.normpath(os.path.join(os.getcwd(), PACKAGE_PARENT)))
from openapi_server.models.edge import Edge
from openapi_server.models.node import Node
from openapi_server.models.q_edge import QEdge
from openapi_server.models.q_node import QNode
from openapi_server.models.query_graph import QueryGraph
from openapi_server.models.knowledge_graph import KnowledgeGraph
from openapi_server.models.node_binding import NodeBinding
from openapi_server.models.edge_binding import EdgeBinding
from openapi_server.models.result import Result


class ARAXResultify:
    ALLOWED_PARAMETERS = {'debug', 'ignore_edge_direction'}

    def __init__(self):
        self.response = None
        self.message = None
        self.parameters = None

    def describe_me(self):
        """
        Little helper function for internal use that describes the actions and what they can do
        :return:
        """
        full_description = """ Creates a list of results from the input query graph (QG) based on the the
information contained in the message knowledge graph (KG). Every subgraph
through the KG that satisfies the GQ is returned. Such use cases include:
- `resultify()` Returns all subgraphs in the knowledge graph that satisfy the
  query graph
- `resultiy(ignore_edge_direction=false)` This mode checks edge directions in
the QG to ensure that matching an edge in the KG to an edge in the QG is only
allowed if the two edges point in the same direction. The default is to not
check edge direction. For example, you may want to include results that include
relationships like `(protein)-[involved_in]->(pathway)` even though the
underlying KG only contains directional edges of the form
`(protein)<-[involved_in]-(pathway)`.  Note that this command will successfully
execute given an arbitrary query graph and knowledge graph provided by the
automated reasoning system, not just ones generated by Team ARA Expander."""
        command_definition = {
            "dsl_command": "resultify()",
            "description": full_description,
            "brief_description": "Creates a list of results consisting of subgraphs from the message knowledge graph "
                                 "that satisfy the query graph.",
            "parameters": {
                "ignore_edge_direction": {
                    "is_required": False,
                    "examples": ["true", "false"],
                    "enum": ["true", "false", "True", "False", "t", "f", "T", "F"],
                    "default": "true",
                    "type": "boolean",
                    "description": "Whether to ignore (vs. obey) edge directions in the query graph when identifying "
                                   "paths that fulfill it.",
                }
            }
        }
        return [command_definition]

    def apply(self, response: ARAXResponse, input_parameters: dict) -> ARAXResponse:

        # Define a default response
        self.response = response
        self.message = response.envelope.message

        # Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        # Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response

        # Store these final parameters for convenience
        response.data['parameters'] = input_parameters
        self.parameters = input_parameters

        response.debug(f"Applying Resultifier to Message with parameters {input_parameters}")

        if not self.message.knowledge_graph:
            self.response.error(f"No message.knowledge_graph exists for resultify to create results from",
                                error_code="NoKG")
            return response

        # call _resultify
        self._resultify(describe=False)

        # Clean up the KG (should only contain nodes used in the results)
        self._clean_up_kg()

        # Return the response and done
        return response

    @staticmethod
    def recompute_qg_keys(response: ARAXResponse) -> ARAXResponse:
        """
        This method annotates nodes and edges in the KG with their respective qnode_keys and qedge_keys according to
        the node/edge bindings in the results. It is meant to be used on an already fully formed message (with results)
        that is being "imported", in a sense, so that ARAX can do further operations on it.
        """
        results = response.envelope.message.results
        kg = response.envelope.message.knowledge_graph
        qg = response.envelope.message.query_graph
        if not results:
            response.error(f"Cannot recompute QG keys for a message that has no results.", error_code="MissingResults")
            return response
        response.info(f"Recomputing QG keys (annotating nodes/edges in the KGs with their QG keys)")
        # First build a map of KG node/edges and their corresponding QG IDs
        kg_node_keys_to_qnode_keys = dict()
        kg_edge_keys_to_qedge_keys = dict()
        for result in results:
            for qnode_key, node_bindings in result.node_bindings.items():
                # FW: This is a hack to get reranking to work. might need to fix later
                if qnode_key not in qg.nodes:
                    for node_binding in node_bindings:
                        if node_binding.id in kg.nodes:
                            del kg.nodes[node_binding.id]
                    response.warning(f"While recomputing qnode keys found a node binding in the results without a corresponding query node. Removing the edge from the KG...")
                    continue
                for node_binding in node_bindings:
                    node_key = node_binding.id
                    if node_key not in kg_node_keys_to_qnode_keys:
                        kg_node_keys_to_qnode_keys[node_key] = set()
                    kg_node_keys_to_qnode_keys[node_key].add(qnode_key)
            for qedge_key, edge_bindings in result.edge_bindings.items():
                # FW: This is a hack to get reranking to work. might need to fix later
                if qedge_key not in qg.edges:
                    for edge_binding in edge_bindings:
                        if edge_binding.id in kg.edges:
                            del kg.edges[edge_binding.id]
                    response.warning(f"While recomputing qedge keys found a edge binding in the results without a corresponding query edge. Removing the edge from the KG...")
                    continue
                for edge_binding in edge_bindings:
                    edge_key = edge_binding.id
                    if edge_key not in kg_edge_keys_to_qedge_keys:
                        kg_edge_keys_to_qedge_keys[edge_key] = set()
                    kg_edge_keys_to_qedge_keys[edge_key].add(qedge_key)
        # Then go ahead and annotate the nodes/edges in the KG with their QG IDs
        for node_key, node in kg.nodes.items():
            if node_key not in kg_node_keys_to_qnode_keys:
                response.error(f"KG contains node(s) that do not appear in any results; cannot recompute their qnode_keys",
                               error_code="InvalidKG")
                return response
            node.qnode_keys = list(kg_node_keys_to_qnode_keys[node_key])
        for edge_key, edge in kg.edges.items():
            if edge_key not in kg_edge_keys_to_qedge_keys:
                response.error(f"KG contains edge(s) that do not appear in any results; cannot recompute their qedge_keys",
                               error_code="InvalidKG")
                return response
            edge.qedge_keys = list(kg_edge_keys_to_qedge_keys[edge_key])
        return response

    def _resultify(self, describe: bool = False):
        """From a knowledge graph and a query graph (both in a Message object), extract a list of Results objects, each containing
        lists of NodeBinding and EdgeBinding objects. Add a list of Results objects to self.message.rseults.

        It is required that `self.parameters` contain the following:
            ignore_edge_direction: a parameter of type `bool` indicating whether
            the direction of an edge in the knowledge graph should be taken into
            account when matching that edge to an edge in the query graph. By
            default, this parameter is `true`. Set this parameter to false in
            order to require that an edge in a subgraph of the KG will only
            match an edge in the QG if both have the same direction (taking into
            account the source/target node mapping). Optional.

        """
        assert self.response is not None
        results = self.message.results
        if results is not None and len(results) > 0:
            self.response.info(f"Clearing previous results and computing a new set of results")
            self.message.results = []
            results = self.message.results
            self.message.n_results = 0

        message = self.message
        parameters = self.parameters

        debug_mode = parameters.get('debug', None)
        if debug_mode is not None:
            try:
                debug_mode = _parse_boolean_case_insensitive(debug_mode)
            except Exception as e:
                self.response.error(str(e))
                return

        for parameter_name in parameters.keys():
            if parameter_name == '':
                continue
            if parameter_name not in ARAXResultify.ALLOWED_PARAMETERS:
                error_string = "parameter type is not allowed in ARAXResultify: " + str(parameter_name)
                if not debug_mode:
                    self.response.error(error_string)
                    return
                else:
                    raise ValueError(error_string)

        kg = message.knowledge_graph
        qg = message.query_graph
        ignore_edge_direction = parameters.get('ignore_edge_direction', None)
        if ignore_edge_direction is not None:
            try:
                ignore_edge_direction = _parse_boolean_case_insensitive(ignore_edge_direction)
            except ValueError as e:
                error_string = "parameter value is not allowed in ARAXResultify: " + str(ignore_edge_direction)
                if not debug_mode:
                    self.response.error(error_string)
                    return
                else:
                    raise e

        try:
            results = _get_results_for_kg_by_qg(kg,
                                                qg,
                                                ignore_edge_direction,
                                                self.response)
            message_code = 'OK'
            code_description = 'Result list computed from KG and QG'
        except Exception as e:
            if not debug_mode:
                code_description = str(e)
                message_code = e.__class__.__name__
                self.response.error(code_description)
                results = []
            else:
                raise e

        message.results = results
        if len(results) == 0 and message_code == 'OK':
            message_code = 'WARNING'
            code_description = 'no results returned'
            if len(kg.nodes) == 0:
                code_description += '; empty knowledge graph'
            self.response.warning(code_description)

        message.n_results = len(results)
        message.code_description = code_description
        message.message_code = message_code

    def _clean_up_kg(self):
        self.response.debug(f"Cleaning up the KG to remove nodes not used in the results")
        results = self.message.results
        kg = self.message.knowledge_graph
        node_keys_used_in_results = {node_binding.id for result in results for node_binding_list in result.node_bindings.values()
                                     for node_binding in node_binding_list}
        cleaned_kg = KnowledgeGraph(nodes={node_key: node for node_key, node in kg.nodes.items() if node_key in node_keys_used_in_results},
                                    edges={edge_key: edge for edge_key, edge in kg.edges.items() if
                                           {edge.subject, edge.object}.issubset(node_keys_used_in_results)})
        self.message.knowledge_graph = cleaned_kg
        self.response.info(f"After cleaning, the KG contains {len(self.message.knowledge_graph.nodes)} nodes and "
                           f"{len(self.message.knowledge_graph.edges)} edges")


def _make_edge_key(node1_id: str,
                   node2_id: str) -> str:
    return node1_id + '->' + node2_id


def _is_specific_query_node(qnode_key: str, qnode: QNode):
    return (qnode_key is not None and ':' in qnode_key) or \
        (qnode.ids is not None and len(qnode.ids) > 0)


def _make_adj_maps(graph: Union[QueryGraph, KnowledgeGraph],
                   directed=True,
                   droploops=True) -> Dict[str, Dict[str, Set[str]]]:
    if directed:
        adj_map_in: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
        adj_map_out: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
    else:
        adj_map: Dict[str, Set[str]] = {node_key: set() for node_key in graph.nodes}
    try:
        for edge in graph.edges.values():
            if droploops and edge.object == edge.subject:
                continue
            if directed:
                edge_node_key = edge.subject
                adj_map_out[edge_node_key].add(edge.object)
                edge_node_key = edge.object
                adj_map_in[edge_node_key].add(edge.subject)
            else:
                edge_node_key = edge.subject
                adj_map[edge_node_key].add(edge.object)
                edge_node_key = edge.object
                adj_map[edge_node_key].add(edge.subject)
    except KeyError:
        raise ValueError("Graph has an edge " + str(edge) + " that refers to a node ID (" + edge_node_key + ") that is not in the graph")
    if directed:
        ret_dict = {'in': adj_map_in, 'out': adj_map_out}
    else:
        ret_dict = {'both': adj_map}
    return ret_dict


def _bfs_dists(adj_map: Dict[str, Set[str]],
               start_node_key: str) -> Dict[str, Union[int, float]]:
    queue = collections.deque([start_node_key])
    distances = {node_key: math.inf for node_key in adj_map.keys()}
    distances[start_node_key] = 0
    while len(queue) > 0:
        node_key = queue.popleft()
        node_dist = distances[node_key]
        assert not math.isinf(node_dist)
        for neighb_node_key in cast(Iterable[str], adj_map[node_key]):
            if math.isinf(distances[neighb_node_key]):
                distances[neighb_node_key] = node_dist + 1
                queue.append(neighb_node_key)
    return distances


def _get_essence_node_for_qg(qg: QueryGraph) -> Optional[str]:
    adj_map = _make_adj_maps(qg, directed=False)['both']
    node_keys_list = list(adj_map.keys())
    all_nodes = set(node_keys_list)
    node_degrees = list(map(len, adj_map.values()))
    leaf_nodes = set(node_keys_list[i] for i, k in enumerate(node_degrees) if k == 1)
    is_set_nodes = set(qnode_key for qnode_key, qnode in qg.nodes.items() if qnode.is_set)
    specific_nodes = set(qnode_key for qnode_key, qnode in qg.nodes.items() if _is_specific_query_node(qnode_key, qnode))
    non_specific_nodes = all_nodes - specific_nodes
    non_specific_leaf_nodes = leaf_nodes & non_specific_nodes

    candidate_essence_nodes = non_specific_leaf_nodes - is_set_nodes
    if len(candidate_essence_nodes) == 0:
        candidate_essence_nodes = non_specific_nodes - is_set_nodes
    if len(candidate_essence_nodes) == 0:
        return None
    elif len(candidate_essence_nodes) == 1:
        return next(iter(candidate_essence_nodes))
    else:
        specific_leaf_nodes = specific_nodes & leaf_nodes
        if len(specific_leaf_nodes) == 0:
            qnode_keys_list = [qnode_key for qnode_key in qg.nodes]
            # TODO: Now that qg.nodes is a dict, don't think there's any order to it.. is this still worthwhile?
            map_node_key_to_pos: Dict[str, Union[int, float]] = {qnode_key: i for i, qnode_key in enumerate(qnode_keys_list)}
            if len(specific_nodes) == 0:
                # return the node key of the non-specific node with the rightmost position in the QG node list
                return sorted(candidate_essence_nodes,
                              key=lambda node_key: map_node_key_to_pos[node_key],
                              reverse=True)[0]
            else:
                if len(specific_nodes) == 1:
                    specific_node_key = next(iter(specific_nodes))
                    return sorted(candidate_essence_nodes,
                                  key=lambda node_key: abs(map_node_key_to_pos[node_key] -
                                                          map_node_key_to_pos[specific_node_key]),
                                  reverse=True)[0]
                else:
                    # there are at least two non-specific leaf nodes and at least two specific nodes
                    return sorted(candidate_essence_nodes,
                                  key=lambda node_key: min([abs(map_node_key_to_pos[node_key] -
                                                               map_node_key_to_pos[specific_node_key]) for
                                                           specific_node_key in specific_nodes]),
                                  reverse=True)[0]
        else:
            if len(specific_leaf_nodes) == 1:
                specific_leaf_node_key = next(iter(specific_leaf_nodes))
                map_node_key_to_pos = _bfs_dists(adj_map, specific_leaf_node_key)
            else:
                all_dist_maps_for_spec_leaf_nodes = {node_key: _bfs_dists(adj_map,
                                                                         node_key) for
                                                     node_key in specific_leaf_nodes}
                qnode_keys_list = [qnode_key for qnode_key in qg.nodes]
                map_node_key_to_pos = {qnode_key: min([dist_map[qnode_key] for dist_map in all_dist_maps_for_spec_leaf_nodes.values()]) for
                                      qnode_key in qnode_keys_list}
            return sorted(candidate_essence_nodes,
                          key=lambda node_key: map_node_key_to_pos[node_key],
                          reverse=True)[0]
    assert False


def _parse_boolean_case_insensitive(input_string:  str) -> bool:
    if input_string is None:
        raise ValueError("invalid value for input_string")
    input_string = input_string.lower()
    if input_string in {"true", "t"}:
        return True
    elif input_string in {"false", "f"}:
        return False
    else:
        raise ValueError("invalid value for input_string")


def _get_qg_without_kryptonite_portions(qg: QueryGraph) -> QueryGraph:
    """
    This function returns a version of the query graph in which kryptonite ("not") qedges and their associated qnodes
    (that aren't otherwised used) have been removed. Resultify should work off of such a version of the QG (effectively
    ignoring kryptonite portions) because handling of kryptonite qedges is done upstream in Expand (see #1119).
    """
    kryptonite_qedge_keys = {qedge_key for qedge_key, qedge in qg.edges.items() if qedge.exclude}
    normal_qedge_keys = set(qg.edges).difference(kryptonite_qedge_keys)
    qnode_keys_used_by_kryptonite_qedges = {qnode_key for qedge_key in kryptonite_qedge_keys for qnode_key in
                                            [qg.edges[qedge_key].subject, qg.edges[qedge_key].object]}
    qnode_keys_used_by_normal_qedges = {qnode_key for qedge_key in normal_qedge_keys for qnode_key in
                                        [qg.edges[qedge_key].subject, qg.edges[qedge_key].object]}
    qnode_keys_used_only_by_kryptonite_qedges = qnode_keys_used_by_kryptonite_qedges.difference(qnode_keys_used_by_normal_qedges)
    return QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items() if qnode_key not in qnode_keys_used_only_by_kryptonite_qedges},
                      edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items() if qedge_key in normal_qedge_keys})


def _get_results_for_kg_by_qg(kg: KnowledgeGraph,              # all nodes *must* have qnode_key specified
                              qg: QueryGraph,
                              ignore_edge_direction: bool = True,
                              log: ARAXResponse = ARAXResponse()) -> List[Result]:

    if ignore_edge_direction is None:
        return _get_results_for_kg_by_qg(kg, qg, log=log)

    # Use a version of the QG in which kryptonite ("not") edges/nodes have been removed (we should ignore these) #1119
    qg = _get_qg_without_kryptonite_portions(qg)

    kg_node_keys_without_qnode_key = [node_key for node_key, node in kg.nodes.items() if not node.qnode_keys]
    if len(kg_node_keys_without_qnode_key) > 0:
        log.error("these node IDs do not have qnode_keys set: " + str(kg_node_keys_without_qnode_key), error_code="MissingQNodeKeys")
        return []

    kg_edge_keys_without_qedge_key = [edge_key for edge_key, edge in kg.edges.items() if not edge.qedge_keys]
    if len(kg_edge_keys_without_qedge_key) > 0:
        log.error("these edges do not have qedge_keys set: " + str(kg_edge_keys_without_qedge_key), error_code="MissingQEdgeKeys")
        return []

    kg_edge_keys_by_qg_key = _get_kg_edge_keys_by_qg_key(kg)
    kg_node_keys_by_qg_key = _get_kg_node_keys_by_qg_key(kg)

    # --------------------- checking for validity of the NodeBindings list --------------
    # we require that every query graph node ID in the "values" slot of the node_bindings_map corresponds to an actual node in the QG
    qnode_keys_mapped_that_are_not_in_qg = [qnode_key for qnode_key in kg_node_keys_by_qg_key if qnode_key not in qg.nodes]
    if len(qnode_keys_mapped_that_are_not_in_qg) > 0:
        log.error("A node in the KG has a qnode_key that does not exist in the QueryGraph: " + str(qnode_keys_mapped_that_are_not_in_qg),
                  error_code="UnknownQNodeKey")
        return []

    # --------------------- checking for validity of the EdgeBindings list --------------
    # we require that every query graph edge ID in the "values" slot of the edge_bindings_map corresponds to an actual edge in the QG
    qedge_keys_mapped_that_are_not_in_qg = [qedge_key for qedge_key in kg_edge_keys_by_qg_key if qedge_key not in qg.edges]
    if len(qedge_keys_mapped_that_are_not_in_qg) > 0:
        log.error("An edge in the KG has a qedge_key that does not exist in the QueryGraph: " + str(qedge_keys_mapped_that_are_not_in_qg),
                  error_code="UnknownQEdgeKey")
        return []

    # --------------------- checking that the source ID and target ID of every edge in KG is a valid KG node ---------------------
    node_keys_for_edges_that_are_not_valid_nodes = [edge.subject for edge in kg.edges.values() if edge.subject not in kg.nodes] + \
                                                   [edge.object for edge in kg.edges.values() if edge.object not in kg.nodes]
    if len(node_keys_for_edges_that_are_not_valid_nodes) > 0:
        log.error("KG has Edges that refer to the following non-existent Nodes: " + str(node_keys_for_edges_that_are_not_valid_nodes),
                  error_code="OrphanEdges")
        return []

    # --------------------- checking that the source ID and target ID of every edge in QG is a valid QG node ---------------------
    invalid_qnode_keys_used_by_qedges = [qedge.subject for qedge in qg.edges.values() if qedge.subject not in qg.nodes] + \
                                        [qedge.object for qedge in qg.edges.values() if qedge.subject not in qg.nodes]
    if len(invalid_qnode_keys_used_by_qedges) > 0:
        log.error("QG has QEdges that refer to the following non-existent QNodes: " + str(invalid_qnode_keys_used_by_qedges),
                  error_code="OrphanQEdges")
        return []

    # --------------------- checking for consistency of edge-to-node relationships, for all edge bindings -----------
    # check that for each bound KG edge, the QG mappings of the KG edges source and target nodes are also the
    # source and target nodes of the QG edge that corresponds to the bound KG edge
    for qedge_key, kg_edge_keys_for_this_qedge_key in kg_edge_keys_by_qg_key.items():
        qg_edge = qg.edges[qedge_key]
        qg_source_node_key = qg_edge.subject
        qg_target_node_key = qg_edge.object
        for edge_key in kg_edge_keys_for_this_qedge_key:
            kg_edge = kg.edges.get(edge_key)
            kg_source_node_key = kg_edge.subject
            kg_target_node_key = kg_edge.object
            if qg_source_node_key != qg_target_node_key:
                edge_valid_in_same_direction = (kg_source_node_key in kg_node_keys_by_qg_key[qg_source_node_key] and
                                                kg_target_node_key in kg_node_keys_by_qg_key[qg_target_node_key])
                edge_valid_in_opposite_direction = (kg_source_node_key in kg_node_keys_by_qg_key[qg_target_node_key] and
                                                    kg_target_node_key in kg_node_keys_by_qg_key[qg_source_node_key])
                edge_is_valid = (edge_valid_in_same_direction or edge_valid_in_opposite_direction) if ignore_edge_direction else edge_valid_in_same_direction
                if not edge_is_valid:
                    kg_source_node = kg.nodes.get(kg_source_node_key)
                    kg_target_node = kg.nodes.get(kg_target_node_key)
                    log.error(f"Edge {edge_key} (fulfilling {qedge_key}) has node(s) that do not fulfill the "
                              f"expected qnodes ({qg_source_node_key} and {qg_target_node_key}). Edge's nodes are "
                              f"{kg_source_node_key} (qnode_keys: {kg_source_node.qnode_keys}) and "
                              f"{kg_target_node_key} (qnode_keys: {kg_target_node.qnode_keys}).", error_code="MismatchedNodes")
                    return []

    # ------------------- checking to make sure option groups in QG are valid ---------------------
    # Qedges with an optional qnode must themselves be labeled optional
    optional_qnode_keys = {qnode_key for qnode_key, qnode in qg.nodes.items() if qnode.option_group_id}
    optional_qedge_keys = {qedge_key for qedge_key, qedge in qg.edges.items() if qedge.option_group_id}
    qedge_keys_with_optional_qnode = {qedge_key for qedge_key, qedge in qg.edges.items() if {qedge.subject, qedge.object}.intersection(optional_qnode_keys)}
    qedge_keys_missing_optional_label = qedge_keys_with_optional_qnode.difference(optional_qedge_keys)
    if qedge_keys_missing_optional_label:
        log.error(f"These qedges need to be labeled optional because they link to an optional qnode: "
                  f"{qedge_keys_missing_optional_label}", error_code="MissingOptionalLabel")
        return []

    # ============= save until SAR can discuss with {EWD,DMK} whether there can be unmapped nodes in the KG =============
    # # if any node in the KG is not bound to a node in the QG, drop the KG node; redefine "kg" as the filtered KG
    # kg_node_keys_keep = {node.id for node in kg.nodes if node.id in node_bindings_map}
    # kg_nodes_keep_list = [node for node in kg.nodes if node.id in kg_node_keys_keep]
    # kg_edges_keep_list = [edge for edge in kg.edges if not (edge.subject in kg_node_keys_keep and
    #                                                         edge.object in kg_node_keys_keep)]
    # kg = KnowledgeGraph(nodes=kg_nodes_keep_list,
    #                     edges=kg_edges_keep_list)
    # ============= save until SAR can discuss with {EWD,DMK} whether there can be unmapped nodes in the KG =============

    # Our goal is to enumerate all distinct "edge-maximal" subgraphs of the KG that each "covers"
    # the QG. A subgraph of KG that "covers" the QG is one for which all of the following conditions hold:
    # (1) under the KG-to-QG node bindings map, the range of the KG subgraph's nodes is the entire set of nodes in the QG
    # (2) for any QG node that has "is_set=True", *all* KG nodes that are bound to the same QG node are in the subgraph
    # (3) every edge in the QG is "covered" by at least one edge in the KG

    results: List[Result] = []

    # Return empty result list if have empty KG
    if not kg.nodes:
        log.debug(f"KG is empty - no results.")
        return results

    # Handle case where QG contains multiple qnodes and no qedges (we'll dump everything in one result)
    if not qg.edges and len(qg.nodes) > 1:
        log.debug(f"QG contains only qnodes (no qedges); will create only one result with all qnodes.")
        result_graph = _create_new_empty_result_graph()
        result_graph["nodes"] = kg_node_keys_by_qg_key
        final_result_graphs = [result_graph]
    else:
        # Build up some indexes for edges in the KG (by their subject/object nodes and qedge keys)
        log.debug(f"Building helper indexes for faster lookup of edges")
        edge_keys_by_subject = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        edge_keys_by_object = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        edge_keys_by_node_pair = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))
        for edge_key, edge in kg.edges.items():
            for qedge_id in edge.qedge_keys:
                edge_keys_by_subject[qedge_id][edge.subject].add(edge_key)
                edge_keys_by_object[qedge_id][edge.object].add(edge_key)
                node_pair_string = f"{edge.subject}--{edge.object}"
                edge_keys_by_node_pair[qedge_id][node_pair_string].add(edge_key)
                if ignore_edge_direction:
                    node_pair_other_direction = f"{edge.object}--{edge.subject}"
                    edge_keys_by_node_pair[qedge_id][node_pair_other_direction].add(edge_key)

        # Create results off the "required" portion of the QG (excluding any qnodes/qedges belong to an "option group")
        log.debug(f"Grabbing only required portion of QG")
        required_qg = QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items() if not qnode.option_group_id},
                                 edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items() if not qedge.option_group_id})
        log.debug(f"Required qnodes are {set(required_qg.nodes)}, required qedges are {set(required_qg.edges)}")
        qg_is_disconnected = _qg_is_disconnected(required_qg)
        if qg_is_disconnected:
            log.error(f"Required portion of QG is disconnected. This isn't allowed! 'Required' qnode IDs are: "
                      f"{[qnode_key for qnode_key in required_qg.nodes]}", error_code="DisconnectedQG")
            return []
        # Make sure all required qnodes/qedges are fulfilled
        unfulfilled_qnode_keys = set(required_qg.nodes).difference(kg_node_keys_by_qg_key)
        unfulfilled_qedge_keys = set(required_qg.edges).difference(kg_edge_keys_by_qg_key)
        if unfulfilled_qnode_keys or unfulfilled_qedge_keys:
            log.debug(f"KG does not fulfill the (required portion of the) QG. Unfulfilled qnodes: {unfulfilled_qnode_keys}. "
                      f"Unfulfilled qedges: {unfulfilled_qedge_keys}.")
            return results
        log.info(f"Creating result graphs for required portion of QG")
        result_graphs_required = _create_result_graphs(kg, required_qg, kg_node_keys_by_qg_key,
                                                       edge_keys_by_subject, edge_keys_by_object,
                                                       edge_keys_by_node_pair, ignore_edge_direction, log)
        log.debug(f"Created {len(result_graphs_required)} required result graphs")

        # Then create results for each of the "option groups" in the QG (including the required portion of the QG with each)
        option_groups_in_qg = {qedge.option_group_id for qedge in qg.edges.values() if qedge.option_group_id}
        if option_groups_in_qg:
            log.info(f"Distinct option groups detected in the QG are: {option_groups_in_qg}")
        option_group_results_dict = dict()
        for option_group_id in option_groups_in_qg:
            # Include qnodes/qedges that are either required or belong to this option group in our QG for this run
            option_group_qg = QueryGraph(nodes={qnode_key: qnode for qnode_key, qnode in qg.nodes.items()
                                                if qnode.option_group_id == option_group_id or not qnode.option_group_id},
                                         edges={qedge_key: qedge for qedge_key, qedge in qg.edges.items()
                                                if qedge.option_group_id == option_group_id or not qedge.option_group_id})
            log.debug(f"For option group {option_group_id}, qnodes are {set(option_group_qg.nodes)}, "
                      f"qedges are {set(option_group_qg.edges)}")
            qg_is_disconnected = _qg_is_disconnected(option_group_qg)
            if qg_is_disconnected:
                log.error(f"Required + option group {option_group_id} portion of the QG is disconnected. "
                          f"This isn't allowed! 'Required'/group {option_group_id} qnode IDs are: "
                          f"{[qnode_key for qnode_key in option_group_qg.nodes]}", error_code="DisconnectedQG")
                return []
            log.info(f"Creating result graphs for option group {option_group_id}")
            result_graphs_for_option_group = _create_result_graphs(kg, option_group_qg, kg_node_keys_by_qg_key,
                                                                   edge_keys_by_subject, edge_keys_by_object,
                                                                   edge_keys_by_node_pair, ignore_edge_direction, log,
                                                                   base_result_graphs=copy.deepcopy(result_graphs_required))
            log.debug(f"Created {len(result_graphs_for_option_group)} option group {option_group_id} result graphs")
            option_group_results_dict[option_group_id] = result_graphs_for_option_group

        # Organize our results for the 'required' portion of the QG by the IDs of their is_set=False nodes
        required_non_set_qnode_keys = [qnode_key for qnode_key, qnode in required_qg.nodes.items() if not qnode.is_set]
        log.debug(f"Required non-set qnodes are: {required_non_set_qnode_keys}")
        result_graphs_by_key = dict()
        for result_graph in result_graphs_required:
            result_key = _get_result_graph_key(result_graph, required_non_set_qnode_keys)
            result_graphs_by_key[result_key] = result_graph
        # Then merge our results for each option group ID into the appropriate "required" results
        if option_groups_in_qg:
            log.info(f"Merging option group result graphs into required result graphs with matching non-set qnodes")
        for option_group_id in option_groups_in_qg:
            for option_group_result_graph in option_group_results_dict[option_group_id]:
                result_key = _get_result_graph_key(option_group_result_graph, required_non_set_qnode_keys)
                corresponding_result_graph = result_graphs_by_key[result_key]
                # Merge this optional result's contents into its corresponding "required" result
                result_graphs_by_key[result_key] = _merge_two_result_graphs(option_group_result_graph, corresponding_result_graph)

        final_result_graphs = list(result_graphs_by_key.values())
        log.debug(f"There are a total of {len(final_result_graphs)} result graphs after merging")

    # Convert the final result graphs into actual Swagger object model results
    log.debug(f"Loading final result graphs into TRAPI object model")
    results = []
    for result_graph in final_result_graphs:
        node_bindings = dict()
        for qnode_key, node_keys in result_graph['nodes'].items():
            node_bindings[qnode_key] = [NodeBinding(id=node_key) for node_key in node_keys]
        edge_bindings = dict()
        for qedge_key, edge_keys in result_graph['edges'].items():
            edge_bindings[qedge_key] = [EdgeBinding(id=edge_key) for edge_key in edge_keys]
        result = Result(node_bindings=node_bindings, edge_bindings=edge_bindings)

        # Fill out the essence for the result
        essence_qnode_key = _get_essence_node_for_qg(qg)
        essence_qnode = qg.nodes.get(essence_qnode_key)
        essence_kg_node_key_set = result_graph['nodes'].get(essence_qnode_key, set())
        if len(essence_kg_node_key_set) == 1:
            essence_kg_node_key = next(iter(essence_kg_node_key_set))
            essence_kg_node = kg.nodes[essence_kg_node_key]
            result.essence = essence_kg_node.name
            if result.essence is None:
                result.essence = essence_kg_node_key
            assert result.essence is not None
            if essence_kg_node.attributes:
                symbol_attributes = [attribute for attribute in essence_kg_node.attributes if attribute.original_attribute_name == "symbol"]
                symbol_attribute = symbol_attributes[0] if symbol_attributes else None
                if symbol_attribute and symbol_attribute.value is not None:
                    result.essence += " (" + str(symbol_attribute.value) + ")"
            result.essence_category = str(essence_qnode.categories) if essence_qnode else None
        elif len(essence_kg_node_key_set) == 0:
            result.essence = cast(str, None)
            result.essence_category = cast(str, None)
        else:
            log.error(f"Result contains more than one node that is a candidate for the essence: "
                      f"{essence_kg_node_key_set}", error_code="EssenceProblem")
            return []

        # Programmatically generating an informative description for each result
        # seems difficult, but having something non-None is required by the
        # database.  Just put in a placeholder for now, as is done by the
        # QueryGraphReasoner
        result.description = "No description available"  # see issue 642

        results.append(result)

    log.info(f"Resultify created {len(results)} results")
    log.total_results_count = len(results)
    return results


def _qg_is_disconnected(qg: QueryGraph) -> bool:
    qnode_keys_examined = {next(qnode_key for qnode_key in qg.nodes)} if qg.nodes else set()  # Start with any qnode
    qnode_keys_remaining = set(qg.nodes).difference(qnode_keys_examined)
    # Repeatedly look for a qnode connected to at least one of the already examined qnodes
    connected_qnode_key, _ = _find_qnode_connected_to_sub_qg(qnode_keys_examined, qnode_keys_remaining, qg)
    while connected_qnode_key and qnode_keys_remaining:
        qnode_keys_remaining.remove(connected_qnode_key)
        qnode_keys_examined.add(connected_qnode_key)
        connected_qnode_key, _ = _find_qnode_connected_to_sub_qg(qnode_keys_examined, qnode_keys_remaining, qg)
    # The QG must be disconnected if there are qnodes remaining that are not connected to any of our examined ones
    return True if not connected_qnode_key and qnode_keys_remaining else False


def _merge_two_result_graphs(optional_result_graph: Dict[str, Dict[str, Set[str]]],
                             required_result_graph: Dict[str, Dict[str, Set[str]]]) -> Dict[str, Dict[str, Set[str]]]:
    # Start with the required result graph and then add in any nodes/edges from the optional graph as appropriate
    merged_result_graph = _copy_result_graph(required_result_graph)
    for qnode_key, kg_node_keys in optional_result_graph["nodes"].items():
        if qnode_key not in required_result_graph["nodes"]:
            merged_result_graph["nodes"][qnode_key] = kg_node_keys
    for qedge_key, kg_edge_keys in optional_result_graph["edges"].items():
        if qedge_key not in required_result_graph["edges"]:
            merged_result_graph["edges"][qedge_key] = kg_edge_keys
    return merged_result_graph


def _get_result_graph_key(result_graph: Dict[str, Dict[str, Set[str]]], non_set_required_qnode_keys: List[str]) -> str:
    non_set_required_qnode_keys.sort()
    non_set_kg_node_keys = [list(result_graph["nodes"][qnode_key])[0] for qnode_key in non_set_required_qnode_keys]
    return "--".join(non_set_kg_node_keys)


def _get_connected_qnode(qnode_key: str, qnode_keys_to_choose_from: [str], query_graph: QueryGraph) -> Optional[str]:
    for qedge in query_graph.edges.values():
        if qedge.subject == qnode_key and qedge.object in qnode_keys_to_choose_from:
            return qedge.object
        elif qedge.object == qnode_key and qedge.subject in qnode_keys_to_choose_from:
            return qedge.subject
    return None


def _get_kg_node_keys_by_qg_key(knowledge_graph: KnowledgeGraph) -> Dict[str, Set[str]]:
    node_keys_by_qg_key = dict()
    for node_key, node in knowledge_graph.nodes.items():
        if node.qnode_keys:
            for qnode_key in node.qnode_keys:
                if qnode_key not in node_keys_by_qg_key:
                    node_keys_by_qg_key[qnode_key] = set()
                node_keys_by_qg_key[qnode_key].add(node_key)
    return node_keys_by_qg_key


def _get_kg_edge_keys_by_qg_key(knowledge_graph: KnowledgeGraph) -> Dict[str, Set[str]]:
    edge_keys_by_qg_key = dict()
    for edge_key, edge in knowledge_graph.edges.items():
        if edge.qedge_keys:
            for qedge_key in edge.qedge_keys:
                if qedge_key not in edge_keys_by_qg_key:
                    edge_keys_by_qg_key[qedge_key] = set()
                edge_keys_by_qg_key[qedge_key].add(edge_key)
    return edge_keys_by_qg_key


def _get_connected_qnode_keys(qnode_key: str, query_graph: QueryGraph) -> Set[str]:
    qnode_keys_used_on_same_qedges = set()
    for qedge in query_graph.edges.values():
        qnode_keys_used_on_same_qedges.add(qedge.subject)
        qnode_keys_used_on_same_qedges.add(qedge.object)
    return qnode_keys_used_on_same_qedges.difference({qnode_key})


def _create_new_empty_result_graph() -> Dict[str, Dict[str, Set[str]]]:
    empty_result_graph = {'nodes': collections.defaultdict(set),
                          'edges': collections.defaultdict(set)}
    return empty_result_graph


def _copy_result_graph(result_graph: Dict[str, Dict[str, Set[str]]]) -> Dict[str, Dict[str, Set[str]]]:
    result_graph_copy = copy.deepcopy(result_graph)
    return result_graph_copy


def _get_edge_node_pair_key(edge: Edge) -> str:
    return "--".join(sorted([edge.subject, edge.object]))


def _get_parallel_qedge_keys(input_qedge: QEdge, query_graph: QueryGraph) -> Set[str]:
    input_qedge_node_keys = {input_qedge.subject, input_qedge.object}
    parallel_qedge_keys = {qedge_key for qedge_key, qedge in query_graph.edges.items() if {qedge.subject, qedge.object} == input_qedge_node_keys}
    return parallel_qedge_keys


def _get_kg_node_adj_map_by_qg_key(kg_node_keys_by_qg_key: Dict[str, Set[str]], knowledge_graph: KnowledgeGraph, query_graph: QueryGraph) -> Dict[str, Dict[str, Dict[str, Set[str]]]]:
    # Returned dict looks like {'n00': {'UMLS:11234': {'n01': {UniProtKB:122}}}}
    # First initiate the overall structure of our (QG-organized) adjacency map
    kg_node_to_node_map = {qnode_key: dict() for qnode_key in kg_node_keys_by_qg_key}
    for qnode_key in query_graph.nodes:
        node_keys_set = kg_node_keys_by_qg_key[qnode_key]
        connected_qnode_keys = _get_connected_qnode_keys(qnode_key, query_graph)
        for node_key in node_keys_set:
            kg_node_to_node_map[qnode_key][node_key] = {connected_qnode_key: set() for connected_qnode_key in connected_qnode_keys}

    # Create a record of which qedge IDs are fulfilled between which node pairs
    node_pair_to_qedge_key_map = dict()
    for edge in knowledge_graph.edges.values():
        node_pair_key = _get_edge_node_pair_key(edge)
        if node_pair_key not in node_pair_to_qedge_key_map:
            node_pair_to_qedge_key_map[node_pair_key] = set()
        node_pair_to_qedge_key_map[node_pair_key] = node_pair_to_qedge_key_map[node_pair_key].union(set(edge.qedge_keys))

    # Fill out which KG nodes are connected to which
    for edge in knowledge_graph.edges.values():
        for qedge_key in edge.qedge_keys:
            # Note: KG may contain some qedge IDs not in this version of the QG due to option group handling
            if qedge_key in query_graph.edges:
                qedge = query_graph.edges[qedge_key]
                # Make sure ALL qedges between these two nodes have been fulfilled before marking them as 'connected'
                parallel_qedge_keys = _get_parallel_qedge_keys(qedge, query_graph)
                if parallel_qedge_keys.issubset(node_pair_to_qedge_key_map[_get_edge_node_pair_key(edge)]):
                    qnode_key_1 = qedge.subject
                    qnode_key_2 = qedge.object
                    if edge.subject in kg_node_keys_by_qg_key[qnode_key_1] and edge.object in kg_node_keys_by_qg_key[qnode_key_2]:
                        kg_node_to_node_map[qnode_key_1][edge.subject][qnode_key_2].add(edge.object)
                        kg_node_to_node_map[qnode_key_2][edge.object][qnode_key_1].add(edge.subject)
                    if edge.subject in kg_node_keys_by_qg_key[qnode_key_2] and edge.object in kg_node_keys_by_qg_key[qnode_key_1]:
                        kg_node_to_node_map[qnode_key_2][edge.subject][qnode_key_1].add(edge.object)
                        kg_node_to_node_map[qnode_key_1][edge.object][qnode_key_2].add(edge.subject)
    return kg_node_to_node_map


def _result_graph_is_fulfilled(result_graph: Dict[str, Dict[str, Set[str]]], query_graph: QueryGraph) -> bool:
    for qnode_key in query_graph.nodes:
        if not result_graph['nodes'].get(qnode_key):
            return False
    for qedge_key in query_graph.edges:
        if not result_graph['edges'].get(qedge_key):
            return False
    return True


def _get_all_adjacent_nodes(kg_node_keys: Set[str], start_qnode_key: str, target_qnode_key: str,
                            kg_node_adj_map_by_qg_key: Dict[str, Dict[str, Dict[str, Set[str]]]]) -> Set[str]:
    """
    This function returns all nodes adjacent to a set of nodes (kg_node_keys) that fulfill the target_qnode_key. The
    start_qnode_key is the qnode ID that the set of input nodes fulfill. Being adjacent to the set of nodes means that
    the node is connected to ANY of the individual input nodes in the set (not ALL).
    """
    connections = [kg_node_adj_map_by_qg_key[start_qnode_key][kg_node_key][target_qnode_key] for kg_node_key in kg_node_keys]
    return {node_key for node_key_set in connections for node_key in node_key_set}


def _find_qnode_connected_to_sub_qg(qnode_keys_to_connect_to: Set[str], qnode_keys_to_choose_from: Set[str], qg: QueryGraph) -> Tuple[str, Set[str]]:
    """
    This function selects a qnode ID from the qnode_keys_to_choose_from that connects to one or more of the qnode IDs
    in the qnode_keys_to_connect_to (which itself could be considered a sub-graph of the QG). It also returns the IDs
    of the connection points (all qnode ID(s) in qnode_keys_to_connect_to that the chosen node connects to).
    """
    for qnode_key_option in qnode_keys_to_choose_from:
        all_qedges_using_qnode = [qedge for qedge in qg.edges.values() if qnode_key_option in {qedge.subject, qedge.object}]
        all_connected_qnode_keys = {qnode_key for qedge in all_qedges_using_qnode for qnode_key in
                                    {qedge.subject, qedge.object}}.difference({qnode_key_option})
        subgraph_connections = qnode_keys_to_connect_to.intersection(all_connected_qnode_keys)
        if subgraph_connections:
            return qnode_key_option, subgraph_connections
    return "", set()


def _get_qg_adj_map_undirected(qg: QueryGraph) -> Dict[str, Set[str]]:
    """
    This function creates a node adjacency map for a given query graph. Example: {"n0": {"n1"}, "n1": {"n0"}}
    """
    qg_adj_map = dict()
    for qnode_key in qg.nodes:
        connected_qedges = [qedge for qedge in qg.edges.values() if qnode_key in {qedge.subject, qedge.object}]
        connected_qnode_keys = {qnode_key for qedge in connected_qedges for qnode_key in
                                {qedge.subject, qedge.object}}.difference({qnode_key})
        qg_adj_map[qnode_key] = connected_qnode_keys
    return qg_adj_map


def _extract_sub_qg_adj_map(qg_adj_map: Dict[str, Set[str]], allowed_qnode_keys: Set[str]) -> Dict[str, Set[str]]:
    """
    This function extracts the node adjacency info for a "subgraph" of the query graph (represented by
    allowed_qnode_keys). Example of qg_adj_map: {"n0": {"n1"}, "n1": {"n0"}}
    """
    return {qnode_key: neighbor_qnode_keys.intersection(allowed_qnode_keys)
            for qnode_key, neighbor_qnode_keys in qg_adj_map.items() if qnode_key in allowed_qnode_keys}


def _clean_up_dead_ends(result_graph: Dict[str, Dict[str, Set[str]]],
                        sub_qg_adj_map: Dict[str, Set[str]],
                        kg_node_adj_map_by_qg_key: Dict[str, Dict[str, Dict[str, Set[str]]]]) -> Dict[str, Dict[str, Set[str]]]:
    """
    This function iteratively removes "dead ends" from a result graph until no more dead ends can be found. Dead ends
    can be thought of as intermediate nodes (typically for is_set=True qnodes) that connect to only a subset of the
    nodes they should be connected to according to the query graph. Only the part of the result graph that has been
    "fulfilled" so far during the result construction process is evaluated here: the sub_qg_adj_map must contain only
    info for qnodes fulfilled thus far.
    """
    fulfilled_qnode_keys = set(sub_qg_adj_map)
    found_dead_ends = True
    while found_dead_ends:
        found_dead_ends = False
        nodes_to_remove = dict()
        # Go through each qnode "role" in our result graph, and check the nodes corresponding to that qnode
        for qnode_key in fulfilled_qnode_keys:
            corresponding_node_keys = result_graph["nodes"][qnode_key]
            required_neighbor_qnode_keys = sub_qg_adj_map[qnode_key]
            # Make sure each node for this qnode ID is connected to at LEAST one node fulfilling each neighbor qnode ID
            for corresponding_node_key in corresponding_node_keys:
                for neighbor_qnode_key in required_neighbor_qnode_keys:
                    # Look for at least one node in the result graph in this neighbor spot that this node is linked to
                    neighbors_in_kg = kg_node_adj_map_by_qg_key[qnode_key][corresponding_node_key][neighbor_qnode_key]
                    if not neighbors_in_kg.intersection(result_graph["nodes"][neighbor_qnode_key]):
                        # Mark this node for removal from this result graph since it's lacking a neighbor here
                        found_dead_ends = True
                        if qnode_key not in nodes_to_remove:
                            nodes_to_remove[qnode_key] = set()
                        nodes_to_remove[qnode_key].add(corresponding_node_key)
        # Actually go through and remove our nodes marked for removal
        for qnode_key, node_keys in nodes_to_remove.items():
            result_graph["nodes"][qnode_key] = result_graph["nodes"][qnode_key].difference(node_keys)
    return result_graph


def _create_result_graphs(kg: KnowledgeGraph,
                          qg: QueryGraph,
                          kg_node_keys_by_qg_key: Dict[str, Set[str]],
                          edge_keys_by_subject: DefaultDict[str, DefaultDict[str, set]],
                          edge_keys_by_object: DefaultDict[str, DefaultDict[str, set]],
                          edge_keys_by_node_pair: DefaultDict[str, DefaultDict[str, set]],
                          ignore_edge_direction: bool = True,
                          log: ARAXResponse = ARAXResponse(),
                          base_result_graphs: Optional[List[dict]] = None) -> List[dict]:
    kg_node_adj_map_by_qg_key = _get_kg_node_adj_map_by_qg_key(kg_node_keys_by_qg_key, kg, qg)
    qg_adj_map = _get_qg_adj_map_undirected(qg)

    # Iteratively construct "result graphs" (initially containing only nodes, not edges) by walking through all qnodes
    log.debug(f"Constructing result graphs qnode by qnode")
    if base_result_graphs:
        # We'll build off of the 'base' result graphs rather than start anew
        result_graphs = base_result_graphs
        qnode_keys_already_handled = set(result_graphs[0]["nodes"])
        qnode_keys_remaining = set(qg.nodes).difference(qnode_keys_already_handled)
    else:
        result_graphs = []
        qnode_keys_already_handled = set()
        qnode_keys_remaining = set(qg.nodes)
    while qnode_keys_remaining:
        # Start with a random qnode if this is our first iteration
        if not qnode_keys_already_handled:
            current_qnode_key = list(qnode_keys_remaining)[0]
            prior_qnode_connections = set()
        # Otherwise find a yet unhandled qnode ID that connects somehow to the part of the QG we've already handled
        else:
            current_qnode_key, prior_qnode_connections = _find_qnode_connected_to_sub_qg(qnode_keys_already_handled, qnode_keys_remaining, qg)
        current_qnode = qg.nodes[current_qnode_key]

        # Initialize our result graphs if this is our first iteration
        if not result_graphs:
            log.debug(f"Initiating result graphs with nodes for {current_qnode_key} (is_set={current_qnode.is_set})")
            all_node_keys_in_kg_for_this_qnode_key = kg_node_keys_by_qg_key.get(current_qnode_key)
            # We'll start with one result graph with ALL corresponding nodes in the KG in this spot if is_set=True
            if current_qnode.is_set:
                log.debug(f"Starting with one result graph because is_set=True for {current_qnode_key}")
                new_result_graph = _create_new_empty_result_graph()
                new_result_graph["nodes"][current_qnode_key] = all_node_keys_in_kg_for_this_qnode_key
                result_graphs.append(new_result_graph)
            # Otherwise, we'll start with a result graph for EACH corresponding node in the KG
            else:
                for node_key in all_node_keys_in_kg_for_this_qnode_key:
                    new_result_graph = _create_new_empty_result_graph()
                    new_result_graph["nodes"][current_qnode_key] = {node_key}
                    result_graphs.append(new_result_graph)
        # Otherwise fan out our existing result graphs, filling out this qnode spot in them based on prior contents
        else:
            log.debug(f"Adding a layer to each result graph for qnode {current_qnode_key} (is_set={current_qnode.is_set})")
            new_result_graphs = []
            sub_qg_adj_map = _extract_sub_qg_adj_map(qg_adj_map, qnode_keys_already_handled.union({current_qnode_key}))
            for result_graph in result_graphs:
                # Figure out which KG nodes could fulfill the current qnode in this result
                prior_qnodes_kg_nodes = {prior_qnode_key: result_graph["nodes"][prior_qnode_key] for prior_qnode_key in prior_qnode_connections}
                current_kg_node_possibilities = [_get_all_adjacent_nodes(corresponding_kg_nodes, prior_qnode_key, current_qnode_key, kg_node_adj_map_by_qg_key)
                                                 for prior_qnode_key, corresponding_kg_nodes in prior_qnodes_kg_nodes.items()]
                # Only keep connections that have links to KG nodes in ALL prior connected qnode roles
                final_connected_kg_nodes = set.intersection(*current_kg_node_possibilities)
                if final_connected_kg_nodes:
                    if current_qnode.is_set:
                        # Replace this result graph with a new one with all valid connections listed under this qnode
                        new_result_graph = _copy_result_graph(result_graph)
                        new_result_graph["nodes"][current_qnode_key] = final_connected_kg_nodes
                        pruned_result_graph = _clean_up_dead_ends(result_graph=new_result_graph,
                                                                  sub_qg_adj_map=sub_qg_adj_map,
                                                                  kg_node_adj_map_by_qg_key=kg_node_adj_map_by_qg_key)
                        new_result_graphs.append(pruned_result_graph)
                    else:
                        # Create a new result graph for each new valid connected node
                        for connected_node_key in final_connected_kg_nodes:
                            new_result_graph = _copy_result_graph(result_graph)
                            new_result_graph["nodes"][current_qnode_key] = {connected_node_key}
                            pruned_result_graph = _clean_up_dead_ends(result_graph=new_result_graph,
                                                                      sub_qg_adj_map=sub_qg_adj_map,
                                                                      kg_node_adj_map_by_qg_key=kg_node_adj_map_by_qg_key)
                            new_result_graphs.append(pruned_result_graph)
            result_graphs = new_result_graphs
        log.debug(f"Current count of result graphs is {len(result_graphs)}")

        # Update our records about which qnodes we've already processed
        qnode_keys_remaining.remove(current_qnode_key)
        qnode_keys_already_handled.add(current_qnode_key)
    log.debug(f"Done assigning nodes to result graphs")

    # Then add edges to our result graphs as appropriate
    log.debug(f"Adding edges to result graphs")
    for result_graph in result_graphs:
        qedge_keys = set(qg.edges)
        for qedge_key in qedge_keys:
            qedge = qg.edges[qedge_key]
            qedge_source_node_ids = result_graph['nodes'][qedge.subject]
            qedge_target_node_ids = result_graph['nodes'][qedge.object]
            # Pick the more efficient method for edge-finding depending on the number of nodes for this result/qedge
            if len(qedge_source_node_ids) < 10 or len(qedge_target_node_ids) < 10:
                possible_node_pairs = {f"{node_1}--{node_2}" for node_1 in qedge_source_node_ids
                                       for node_2 in qedge_target_node_ids}
                for node_pair in possible_node_pairs:
                    ids_of_matching_edges = edge_keys_by_node_pair[qedge_key].get(node_pair, set())
                    result_graph['edges'][qedge_key].update(ids_of_matching_edges)
            else:
                # This technique is more efficient when there are large numbers of both subject and object nodes
                edges_with_matching_subject = {edge_key for source_node in qedge_source_node_ids
                                               for edge_key in edge_keys_by_subject[qedge_key][source_node]}
                edges_with_matching_object = {edge_key for target_node in qedge_target_node_ids
                                              for edge_key in edge_keys_by_object[qedge_key][target_node]}
                result_graph['edges'][qedge_key] = edges_with_matching_subject.intersection(edges_with_matching_object)
                if ignore_edge_direction:
                    edges_with_reverse_subject = {edge_key for target_node in qedge_target_node_ids
                                                  for edge_key in edge_keys_by_subject[qedge_key][target_node]}
                    edges_with_reverse_object = {edge_key for source_node in qedge_source_node_ids
                                                 for edge_key in edge_keys_by_object[qedge_key][source_node]}
                    result_graph['edges'][qedge_key].update(edges_with_reverse_subject.intersection(edges_with_reverse_object))

    final_result_graphs = [result_graph for result_graph in result_graphs if _result_graph_is_fulfilled(result_graph, qg)]
    return final_result_graphs




