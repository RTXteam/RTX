#!/bin/env python3
import sys
def eprint(*args, **kwargs): print(*args, file=sys.stderr, flush=True, **kwargs)

import os
import json
import ast
import re
import copy

from datetime import datetime
import numpy as np
import requests

from ARAX_response import ARAXResponse
from ARAX_resultify import ARAXResultify
from query_graph_info import QueryGraphInfo
from knowledge_graph_info import KnowledgeGraphInfo

sys.path.append(os.path.dirname(os.path.abspath(__file__))+"/../../")
from RTXConfiguration import RTXConfiguration

sys.path.append(os.path.dirname(os.path.abspath(__file__))+"/../../UI/OpenAPI/python-flask-server/")
from openapi_server.models.response import Response
from openapi_server.models.message import Message
from openapi_server.models.knowledge_graph import KnowledgeGraph
from openapi_server.models.query_graph import QueryGraph
from openapi_server.models.q_node import QNode
from openapi_server.models.q_edge import QEdge

sys.path.append(os.path.dirname(os.path.abspath(__file__))+"/../NodeSynonymizer")
from node_synonymizer import NodeSynonymizer
sys.path.append(os.path.dirname(os.path.abspath(__file__))+"/../BiolinkHelper")
from biolink_helper import BiolinkHelper


class ARAXMessenger:

    #### Constructor
    def __init__(self):
        self.response = None
        self.envelope = None
        self.message = None
        self.parameters = None

    def describe_me(self):
        """
        Self-documentation method for internal use that returns the available actions and what they can do
        :return: A list of allowable actions supported by this class
        :rtype: list
        """
        description_list = []
        description_list.append(self.create_envelope(0,describe=True))
        description_list.append(self.add_qnode(0,0,describe=True))
        description_list.append(self.add_qedge(0,0,describe=True))
        return description_list


    # #### Create a fresh ARAXResponse object as an envelple and fill with defaults
    def create_envelope(self, response, describe=False):
        """
        Creates a basic empty ARAXResponse object with basic boilerplate metadata
        :return: ARAXResponse object with execution information and the new message object inside the data envelope
        :rtype: ARAXResponse
        """

        # #### Command definition for autogenerated documentation
        command_definition = {
            'dsl_command': 'create_envelope()',
            'description': """The `create_envelope` command creates a basic empty Response object with basic boilerplate metadata
                such as resource_id, schema_version, etc. filled in. This DSL command takes no arguments. This command is not explicitly
                necessary, as it is called implicitly when needed. e.g. If a DSL program begins with add_qnode(), the
                create_envelope() will be executed automatically if there is not yet a ARAXResponse. If there is already ARAXResponse in memory,
                then this command will destroy the previous one (in memory) and begin a new envelope.""",
            'parameters': {
            }
        }

        if describe:
            return command_definition


        #### Store the passed response object
        self.response = response
    
        #### Create the top-level Response object called an envelope
        response.info("Creating an empty template TRAPI Response")
        envelope = Response()
        response.envelope = envelope
        self.envelope = envelope

        # Create a Message object and place it in the envelope
        message = Message()
        response.envelope.message = message
        self.message = message

        #### Fill it with default information
        biolink_helper = BiolinkHelper()
        envelope.id = None
        envelope.type = "translator_reasoner_response"
        envelope.resource_id = "ARAX"
        envelope.tool_version = RTXConfiguration().version
        envelope.schema_version = "1.4.0"
        envelope.biolink_version = biolink_helper.get_current_arax_biolink_version()
        envelope.status = "OK"
        envelope.description = "Created empty template response"
        envelope.context = "https://raw.githubusercontent.com/biolink/biolink-model/master/context.jsonld"
        envelope.logs = response.messages
        envelope.datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

		#### Create an empty master knowledge graph
        message.knowledge_graph = KnowledgeGraph()
        message.knowledge_graph.nodes = {}
        message.knowledge_graph.edges = {}

		#### Create an empty query graph
        message.query_graph = QueryGraph()
        message.query_graph.nodes = {}
        message.query_graph.edges = {}

        #### Create empty results
        message.results = []

        #### Return the response
        response.data['envelope'] = envelope
        return response


    ###############################################################################################
    # #### Add a new QNode
    def add_qnode(self, response, input_parameters, describe=False):
        """
        Adds a new QNode object to the QueryGraph inside the Message object
        :return: ARAXResponse object with execution information
        :rtype: ARAXResponse
        """

        # #### Command definition for autogenerated documentation
        command_definition = {
            'dsl_command': 'add_qnode()',
            'description': """The `add_qnode` method adds an additional QNode to the QueryGraph in the Message object.""",
            'parameters': {
                'key': { 
                    'is_required': False,
                    'examples': [ 'n00', 'n01' ],
                    'default': '',
                    'type': 'string',
                    'description': """Any string that is unique among all QNode key fields, with recommended format n00, n01, n02, etc.
                        If no value is provided, autoincrementing values beginning for n00 are used.""",
                    },
                'ids': {
                    'is_required': False,
                    'examples': [ 'DOID:9281', '[UniProtKB:P12345,UniProtKB:Q54321]' ],
                    'type': 'string',
                    'description': 'A list (n >= 1) of compact URI (CURIE) (e.g. [DOID:9281] or [UniProtKB:P12345,UniProtKB:Q54321])',
                    },
                'name': {
                    'is_required': False,
                    'examples': [ 'hypertension', 'insulin' ],
                    'type': 'string',
                    'description': 'Any name of a bioentity that will be resolved into a CURIE if possible or result in an error if not (e.g. hypertension, insulin)',
                    },
                'categories': {
                    'is_required': False,
                    'examples': [ 'protein', 'chemical_substance', 'disease' ],
                    'type': 'ARAXnode',
                    'description': 'A list (n >= 1) of valid BioLink bioentity categories (e.g. biolink:Protein, biolink:ChemicalEntity, biolink:Disease)',
                    },
                'is_set': {
                    'is_required': False,
                    'enum': [ "true", "false", "True", "False", "t", "f", "T", "F" ],
                    'examples': [ 'true', 'false' ],
                    'type': 'boolean',
                    'description': 'If set to true, this QNode represents a set of nodes that are all in common between the two other linked QNodes (assumed to be false if not specified or value is not recognized as true/t case insensitive)'
                    },
                'option_group_id': {
                    'is_required': False,
                    'examples': [ '1', 'a', 'b2', 'option'],
                    'type': 'string',
                    'description': 'A group identifier indicating a group of nodes and edges should either all be included or all excluded. An optional match for all elements in this group. If not included Node will be treated as required.'
                    },
            }
        }

        if describe:
            return command_definition

        #### Extract the message to work on
        message = response.envelope.message
        self.response = response
        self.envelope = response.envelope
        self.messsage = message

        #### Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        #### Define a complete set of allowed parameters and their defaults
        parameters = {
            'key': None,
            'ids': None,
            'name': None,
            'categories': None,
            'is_set': None,
            'option_group_id': None,
        }

        #### Loop through the input_parameters and override the defaults and make sure they are allowed
        for key,value in input_parameters.items():
            if key not in parameters:
                response.error(f"Supplied parameter {key} is not permitted", error_code="UnknownParameter")
            else:
                parameters[key] = value

        #### Check for option_group_id and is_set:
        if parameters['option_group_id'] is not None and parameters['ids'] is None and parameters['name'] is None:
            if parameters['is_set'] is None:
                parameters['is_set'] = 'true'
                response.warning(f"An 'option_group_id' was set to {parameters['option_group_id']}, but 'is_set' was not an included parameter. It must be true when an 'option_group_id' is given, so automatically setting to true. Avoid this warning by explictly setting to true.")
            elif not ( parameters['is_set'].lower() == 'true' or parameters['is_set'].lower() == 't' ):
                response.error(f"When an 'option_group_id' is given 'is_set' must be set to true. However, supplied input for parameter 'is_set' was {parameters['is_set']}.", error_code="InputMismatch")


        #### Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response


        #### Now apply the filters. Order of operations is probably quite important
        #### Scalar value filters probably come first like minimum_confidence, then complex logic filters
        #### based on edge or node properties, and then finally maximum_results
        response.info(f"Adding a QueryNode to Message with input parameters {parameters}")

        #### Make sure there's a query_graph already here
        if message.query_graph is None:
            message.query_graph = QueryGraph()
            message.query_graph.nodes = {}
            message.query_graph.edges = {}
        if message.query_graph.nodes is None:
            message.query_graph.nodes = {}

        #### Set up the NodeSynonymizer to find curies and names
        synonymizer = NodeSynonymizer()

        # Create the QNode and set the key
        qnode = QNode()
        if parameters['key'] is not None:
            key = parameters['key']
            if key in message.query_graph.nodes:
                response.error(f"Duplicate key '{key}' specified when trying to create a new QNode", error_code="QNodeDuplicateKey")
                return response
        else:
            key = self.__get_next_free_node_key()

        if parameters['option_group_id'] is not None:
            qnode.option_group_id = parameters['option_group_id']
        
        # Set the is_set parameter to what the user selected
        if parameters['is_set'] is not None:
            qnode.is_set = ( parameters['is_set'].lower() == 'true' or parameters['is_set'].lower() == 't' )

        #### If the ids is specified, try to find that
        if parameters['ids'] is not None:

            # If the ids is a scalar then treat it here as a list of one
            if isinstance(parameters['ids'], str):
                id_list = [ parameters['ids'] ]

            # Or else set it up as a list
            elif isinstance(parameters['ids'], list):
                id_list = parameters['ids']
                is_id_a_list = True
                if len(id_list) == 1:
                    if qnode.is_set == True:
                        response.warning(f"Specified ids '{parameters['ids']}' is singular, but is_set=true, which doesn't make sense, so automatically setting to false. Avoid this warning by not explictly setting to true.")
                        qnode.is_set = False

            # Or if it's neither a list or a string, then error out. This cannot be handled at present
            else:
                response.error(f"Specified ids '{parameters['ids']}' is neither a string nor a list. This cannot to handled", error_code="IdNotListOrScalar")
                return response

            # Check whether NodeSynonymizer recognizes all IDs on this qnode
            response.debug(f"Looking up ids {id_list} in NodeSynonymizer")
            synonymizer_results = synonymizer.get_canonical_curies(id_list)
            unrecognized_ids = {synonymizer_result for synonymizer_result in synonymizer_results
                                if not synonymizer_result}
            if unrecognized_ids:
                response.debug(f"NodeSynonymizer did not recognize nodes {unrecognized_ids}, but will continue with them")
            qnode.ids = id_list

            if 'categories' in parameters and parameters['categories'] is not None:
                if isinstance(parameters['categories'], str):
                    qnode.categories = [ parameters['categories'] ]
                else:
                    qnode.categories = parameters['categories']

            message.query_graph.nodes[key] = qnode
            return response

        #### If the name is specified, try to find that
        if parameters['name'] is not None:
            name = parameters['name']
            response.debug(f"Looking up id for name '{name}' in NodeSynonymizer")
            synonymizer_results = synonymizer.get_canonical_curies(curies=[name], names=[name])

            if synonymizer_results[name] is None:
                response.error(f"A node with name '{name}' is not in our knowledge graph", error_code="UnresolvableNodeName")
                return response
 
            qnode.ids = [ synonymizer_results[name]['preferred_curie'] ]
            response.info(f"Creating QueryNode with ids '{qnode.ids}' for name '{name}'")
            if parameters['categories'] is not None:
                if isinstance(parameters['categories'], str):
                    qnode.categories = [ parameters['categories'] ]
                else:
                    qnode.categories = parameters['categories']
            message.query_graph.nodes[key] = qnode
            return response

        #### If the categories is specified, just add that categories. There should be checking that it is legal. FIXME
        if parameters['categories'] is not None:
            if isinstance(parameters['categories'], str):
                qnode.categories = [ parameters['categories'] ]
            else:
                qnode.categories = parameters['categories']
            if parameters['is_set'] is not None:
                qnode.is_set = (parameters['is_set'].lower() == 'true')
            message.query_graph.nodes[key] = qnode
            return response

        #### If we get here, it means that all three main parameters are null. Just a generic node with no categories or anything. This is okay.
        message.query_graph.nodes[key] = qnode
        return response


    ###############################################################################################
    #### Get the next free node key like nXX where XX is a zero-padded integer starting with 00
    def __get_next_free_node_key(self):

        #### Set up local references to the message and verify the query_graph nodes
        message = self.envelope.message
        if message.query_graph is None:
            message.query_graph = QueryGraph()
            message.query_graph.nodes = []
            message.query_graph.edges = []
        if message.query_graph.nodes is None:
            message.query_graph.nodes = []
        qnodes = message.query_graph.nodes

        #### Find the first unused key
        index = 0
        while 1:
            pad = '0'
            if index > 9:
                pad = ''
            potential_node_key = f"n{pad}{str(index)}"
            if potential_node_key not in qnodes:
                return potential_node_key
            index += 1


    ###############################################################################################
    #### Add a new QEdge
    def add_qedge(self, response, input_parameters, describe=False):
        """
        Adds a new QEdge object to the QueryGraph inside the Message object
        :return: ARAXResponse object with execution information
        :rtype: ARAXResponse
        """

        # #### Command definition for autogenerated documentation
        command_definition = {
            'dsl_command': 'add_qedge()',
            'description': """The `add_qedge` command adds an additional QEdge to the QueryGraph in the Message object. Currently
                subject and object QNodes must already be present in the QueryGraph. The specified type is not currently checked that it is a
                valid Translator/BioLink relationship type, but it should be.""",
            'parameters': {
                'key': { 
                    'is_required': False,
                    'examples': [ 'e00', 'e01' ],
                    'default': '',
                    'type': 'string',
                    'description': """Any string that is unique among all QEdge key fields, with recommended format e00, e01, e02, etc.
                        If no value is provided, autoincrementing values beginning for e00 are used.""",
                    },
                'subject': {
                    'is_required': True,
                    'examples': [ 'n00', 'n01' ],
                    'type': 'string',
                    'description': 'key of the source QNode already present in the QueryGraph (e.g. n00, n01)',
                    },
                'object': {
                    'is_required': True,
                    'examples': [ 'n01', 'n02' ],
                    'type': 'string',
                    'description': 'key of the target QNode already present in the QueryGraph (e.g. n01, n02)',
                    },
                'predicates': {
                    'is_required': False,
                    'examples': [ [ 'biolink:physically_interacts_with' ], [ 'biolink:participates_in' ] ],
                    'type': 'ARAXedge',
                    'description': 'A list (n >= 1) of valid BioLink relationship predicates (e.g. [physically_interacts_with], [participates_in])',
                    },
                'option_group_id': {
                    'is_required': False,
                    'examples': [ '1', 'a', 'b2', 'option'],
                    'type': 'string',
                    'description': 'A group identifier indicating a group of nodes and edges should either all be included or all excluded. An optional match for all elements in this group. If not included Node will be treated as required.'
                    },
                'exclude': {
                    'is_required': False,
                    'enum': [ 'true', 'false' ],
                    'examples': [ 'true', 'false' ],
                    'type': 'boolean',
                    'description': 'If set to true, results with this node will be excluded. If set to false or not included nodes will be treated as part of a normal query.'
                    },
            }
        }

        if describe:
            return command_definition


        #### Extract the message to work on
        message = response.envelope.message
        self.response = response
        self.envelope = response.envelope
        self.messsage = message

        #### Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        #### Define a complete set of allowed parameters and their defaults
        parameters = {
            'key': None,
            'subject': None,
            'object': None,
            'predicates': None,
            'option_group_id': None,
            'exclude': None,
        }

        #### Loop through the input_parameters and override the defaults and make sure they are allowed
        for key,value in input_parameters.items():
            if key not in parameters:
                response.error(f"Supplied parameter {key} is not permitted", error_code="UnknownParameter")
            else:
                parameters[key] = value
        #### Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response

        #### Store these final parameters for convenience
        response.data['parameters'] = parameters
        self.parameters = parameters


        #### Now apply the filters. Order of operations is probably quite important
        #### Scalar value filters probably come first like minimum_confidence, then complex logic filters
        #### based on edge or node properties, and then finally maximum_results
        response.info(f"Adding a QueryEdge to Message with parameters {parameters}")

        #### Make sure there's a query_graph already here
        if message.query_graph is None:
            message.query_graph = QueryGraph()
            message.query_graph.nodes = {}
            message.query_graph.edges = {}
        if message.query_graph.edges is None:
            message.query_graph.edges = {}

        #### Create a QEdge
        qedge = QEdge()
        if parameters['key'] is not None:
            key = parameters['key']
            if key in message.query_graph.edges:
                response.error(f"Duplicate key '{key}' specified when trying to create a new QEdge", error_code="QEdgeDuplicateKey")
                return response
        else:
            key = self.__get_next_free_edge_key()

        #### Get the list of available node_keys
        qnodes = message.query_graph.nodes

        #### Add the subject
        if parameters['subject'] is not None:
            if parameters['subject'] not in qnodes:
                response.error(f"While trying to add QEdge, there is no QNode with key {parameters['subject']}", error_code="UnknownSourceKey")
                return response
            qedge.subject = parameters['subject']
        else:
            response.error(f"While trying to add QEdge, subject is a required parameter", error_code="MissingSourceKey")
            return response

        #### Add the object
        if parameters['object'] is not None:
            if parameters['object'] not in qnodes:
                response.error(f"While trying to add QEdge, there is no QNode with key {parameters['object']}", error_code="UnknownTargetKey")
                return response
            qedge.object = parameters['object']
        else:
            response.error(f"While trying to add QEdge, object is a required parameter", error_code="MissingTargetKey")
            return response

        #### Add the predicates if any. Need to verify they are allowed predicates. FIXME
        if parameters['predicates'] is not None:
            if isinstance(parameters['predicates'], str):
                qedge.predicates = [ parameters['predicates'] ]
            else:
                qedge.predicates = parameters['predicates']

        if parameters['exclude'] is not None:
            if parameters['exclude'] in {'t', 'T', 'true', 'True'}:
                qedge.exclude = True
            elif parameters['exclude'] in {'f', 'F', 'false', 'False'}:
                qedge.exclude = False
            elif parameters['exclude'] not in {True, False}:
                response.error(f"Supplied input, {parameters['exclude']}, for the 'exclude' parameter is not valid. Acceptable inputs are t, T, f, F, true, True, false, and False.", error_code="UnknownInput")
        else:
            qedge.exclude = False

        if parameters['option_group_id'] is not None:
            qedge.option_group_id = parameters['option_group_id']

        #### Add it to the query_graph edge list
        message.query_graph.edges[key] = qedge

        #### Return the response
        return response


    ###############################################################################################
    #### Get the next free edge key like eXX where XX is a zero-padded integer starting with 00
    def __get_next_free_edge_key(self):

        #### Set up local references to the message and verify the query_graph nodes
        message = self.envelope.message
        if message.query_graph is None:
            message.query_graph = QueryGraph()
            message.query_graph.nodes = {}
            message.query_graph.edges = {}
        if message.query_graph.edges is None:
            message.query_graph.edges = {}
        qedges = message.query_graph.edges

        #### Find the first unused key
        index = 0
        while 1:
            pad = '0'
            if index > 9:
                pad = ''
            potential_edge_key = f"e{pad}{str(index)}"
            if potential_edge_key not in qedges:
                return potential_edge_key
            index += 1


    ###############################################################################################
    #### Remove a QEdge
    def remove_qedge(self, response, input_parameters, describe=False):
        """
        Removes a QEdge object in the QueryGraph inside the Message object
        :return: ARAXResponse object with execution information
        :rtype: ARAXResponse
        """

        # #### Command definition for autogenerated documentation
        command_definition = {
            'dsl_command': 'remove_qedge()',
            'description': """The `remove_qedge` command removes a QEdge from the QueryGraph in the Message object. Currently
                the only way to specify the desired edge to remove it by its key.""",
            'parameters': {
                'key': { 
                    'is_required': True,
                    'examples': [ 'e00', 'e01' ],
                    'default': '',
                    'type': 'string',
                    'description': """The key of the QEdge to remove, such as e00, e01, e02, etc.""",
                    },
           }
        }

        if describe:
            return command_definition


        #### Extract the message to work on
        message = response.envelope.message

        #### Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        #### Define a complete set of allowed parameters and their defaults
        parameters = {
            'key': None,
        }

        #### Loop through the input_parameters and override the defaults and make sure they are allowed
        for key,value in input_parameters.items():
            if key not in parameters:
                response.error(f"Supplied parameter {key} is not permitted", error_code="UnknownParameter")
            else:
                parameters[key] = value
        #### Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response

        #### Store these final parameters for convenience
        response.data['parameters'] = parameters
        self.parameters = parameters


        #### Now apply the filters. Order of operations is probably quite important
        #### Scalar value filters probably come first like minimum_confidence, then complex logic filters
        #### based on edge or node properties, and then finally maximum_results
        response.info(f"Removing QueryEdge with parameters {parameters}")

        #### Make sure there's a query_graph already here
        if message.query_graph is None:
            response.error(f"While trying to remove a QEdge, there is no QueryGraph", error_code="QueryGraphNotFound")
            return response
        if message.query_graph.edges is None:
            response.error(f"While trying to remove a QEdge, there are no edges in the QueryGraph", error_code="NoEdgesFound")
            return response

        key = parameters['key']
        if key in message.query_graph.edges:
            del message.query_graph.edges[key]
        else:
            response.error(f"While trying to remove a QEdge, no QEdge with key {key} was found", error_code="QEdgekeyNotfound")
            return response

        #### Return the response
        return response


    ###############################################################################################
    #### Fetch a message by its URI, return the message
    def fetch_message(self, message_uri):

        result = self.apply_fetch_message(self.message, { 'uri': message_uri })
        return self.message


    #### Fetch a message by its URI, return a full response
    def apply_fetch_message(self, message, input_parameters, describe=False):
        """
        Adds a new QEdge object to the QueryGraph inside the Message object
        :return: ARAXResponse object with execution information
        :rtype: ARAXResponse
        """

        # #### Command definition for autogenerated documentation
        command_definition = {
            'dsl_command': 'fetch_message()',
            'description': """The `fetch_message` command fetches a remote Message by its id and can then allow further processing on it.""",
            'parameters': {
                'id': { 
                    'is_required': True,
                    'examples': [ 'https://arax.ncats.io/api/arax/v1.0/message/1' ],
                    'default': '',
                    'type': 'string',
                    'description': """A URL/URI that identifies the Message to be fetched""",
                    },
            }
        }

        if describe:
            return command_definition


        #### Define a default response
        response = ARAXResponse()
        self.response = response
        self.message = message

        #### Basic checks on arguments
        if not isinstance(input_parameters, dict):
            response.error("Provided parameters is not a dict", error_code="ParametersNotDict")
            return response

        #### Define a complete set of allowed parameters and their defaults
        parameters = {
            'uri': None,
        }

        #### Loop through the input_parameters and override the defaults and make sure they are allowed
        for key,value in input_parameters.items():
            if key not in parameters:
                response.error(f"Supplied parameter {key} is not permitted", error_code="UnknownParameter")
            else:
                parameters[key] = value
        #### Return if any of the parameters generated an error (showing not just the first one)
        if response.status != 'OK':
            return response

        #### Store these final parameters for convenience
        response.data['parameters'] = parameters
        self.parameters = parameters


        #### Basic checks on arguments
        message_uri = input_parameters['uri']
        if not isinstance(message_uri, str):
            response.error("Provided parameter is not a string", error_code="ParameterNotString")
            return response

        response.info(f"Fetching Message via GET to '{message_uri}'")
        response_content = requests.get(message_uri, headers={'accept': 'application/json'})
        status_code = response_content.status_code

        if status_code != 200:
            response.error(f"GET to '{message_uri}' returned HTTP code {status_code} and content '{response_content.content}'", error_code="GETFailed")
            response.error(f"GET to '{message_uri}' returned HTTP code {status_code}", error_code="GETFailed")
            return response

        #### Unpack the response content into a dict and dump
        try:
            response_dict = response_content.json()
            envelope = Response().from_dict(response_dict)
        except:
            response.error(f"Error converting response from '{message_uri}' to objects from content", error_code="UnableToParseContent")
            return response

        #### Store the decoded message and return response
        message = envelope.message
        self.message = message
        self.envelope = envelope
        n_results = 0
        n_qg_nodes = 0
        n_kg_nodes = 0
        if message.results is not None and isinstance(message.results,list):
            n_results = len(message.results)
        if message.query_graph is not None and isinstance(message.query_graph,QueryGraph) and isinstance(message.query_graph.nodes,list):
            n_qg_nodes = len(message.query_graph.nodes)
        if message.knowledge_graph is not None and isinstance(message.knowledge_graph,KnowledgeGraph) and isinstance(message.knowledge_graph.nodes,list):
            n_kg_nodes = len(message.knowledge_graph.nodes)
        response.info(f"Retreived Message with {n_qg_nodes} QueryGraph nodes, {n_kg_nodes} KnowledgeGraph nodes, and {n_results} results")
        if n_qg_nodes > 0 and n_kg_nodes > 0 and n_results > 0:
            resultifier = ARAXResultify()
            response.envelope = envelope
            resultifier.recompute_qg_keys(response)
        return response


    #### Convert a Message as a dict to a Message as objects
    def from_dict(self, message):

        if str(message.__class__) == "<class 'openapi_server.models.message.Message'>":
            return message


        #### 2021-02 Temporary hack. Convert some lists into strings and some strings in lists
        #print("Fixing edges", file=sys.stderr, flush=True)
        if 'query_graph' in message and message['query_graph'] is not None:
            if 'edges' in message['query_graph'] and message['query_graph']['edges'] is not None:
                for edge_key, edge in message['query_graph']['edges'].items():
                    if 'predicates' in edge and edge['predicates'] is not None:
                        if isinstance(edge['predicates'], str):
                            edge['predicates'] = [ edge['predicates'] ]

            #print("Fixing nodes", file=sys.stderr, flush=True)
            if 'nodes' in message['query_graph'] and message['query_graph']['nodes'] is not None:
                for node_key, node in message['query_graph']['nodes'].items():
                    if 'categories' in node and node['categories'] is not None:
                        if isinstance(node['categories'], str):
                            #eprint(f"node {node_key} categories {node['categories']}")
                            node['categories'] = [ node['categories'] ]
                    if 'ids' in node and node['ids'] is not None:
                        if isinstance(node['ids'], str):
                            #eprint(f"node {node_key} ids {node['ids']}")
                            node['ids'] = [ node['ids'] ]

        if 'knowledge_graph' in message and message['knowledge_graph'] is not None:
            if 'nodes' in message['knowledge_graph'] and message['knowledge_graph']['nodes'] is not None:
                for node_key, node in message['knowledge_graph']['nodes'].items():
                    if 'categories' in node and node['categories'] is not None:
                        if isinstance(node['categories'], str):
                            node['categories'] = [ node['categories'] ]


        #eprint("Done")
        #eprint(json.dumps(message,indent=2,sort_keys=True))

        #### Deserialize
        message = Message().from_dict(message)

        #### Revert some things back temporarily

#        if message.query_graph is not None:
#            print("DEFixing edges", file=sys.stderr, flush=True)
#            if message.query_graph.edges is not None:
#                for edge_key, edge in message.query_graph.edges.items():
#                    if edge.predicate is not None:
#                        if isinstance(edge.predicate, list):
#                            if len(edge.predicate) > 0:
#                                edge.predicate = edge.predicate[0]
#                            else:
#                                edge.predicate = None

#            print("DEFixing nodes", file=sys.stderr, flush=True)
#            if message.query_graph.nodes is not None:
#                for node_key, node in message.query_graph.nodes.items():
#                    if node.category is not None:
#                        if isinstance(node.category, list):
#                            if len(node.category) > 0:
#                                node.category = node.category[0]
#                            else:
#                                node.category = None
                        # id is NOT fixed




        # When tested from ARAX_query_graph_interpreter, none of this subsequent stuff is needed

        #print(message.query_graph.__class__)
        #message.query_graph = QueryGraph().from_dict(message.query_graph)
        #message.knowledge_graph = KnowledgeGraph().from_dict(message.knowledge_graph)

        #### This is an unfortunate hack that fixes qnode.curie entries
        #### Officially a curie can be a str or a list. But Swagger 2.0 only permits one type and we set it to str
        #### so when it gets converted from_dict, the list gets converted to a str because that's its type
        #### Here we force it back. This should no longer be needed when we are properly on OpenAPI 3.0
        #if message.query_graph is not None and message.query_graph.nodes is not None:
        #    for qnode_key,qnode in message.query_graph.nodes.items():
        #        print(qnode.__class__)
                #if qnode.id is not None and isinstance(qnode.id,str):
                #    if qnode.id[0:2] == "['":
                #        try:
                #            qnode.id = ast.literal_eval(qnode.id)
                #        except:
                #            pass

        #new_nodes = []
        #for qnode in message.query_graph.nodes:
        #    print(type(qnode))
        #    new_nodes.append(QNode().from_dict(qnode))
        #message.query_graph.nodes = new_nodes
        #for qedge in message.query_graph.edges:
        #    new_edges.append(QEdge().from_dict(qedge))
        #message.query_graph.edges = new_edges

        #if message.results is not None:
        #    for result in message.results:
        #        if result.result_graph is not None:
        #            #eprint(str(result.result_graph.__class__))
        #            if str(result.result_graph.__class__) != "<class 'openapi_server.models.knowledge_graph.KnowledgeGraph'>":
        #                result.result_graph = KnowledgeGraph().from_dict(result.result_graph)

        return message



##########################################################################################
def main():

    #### Create a response object that contains the final results of our efforts
    response = ARAXResponse()
    #### Setting the output to STDERR will write out information as we go along in addition to supplying it with the response
    #ARAXResponse.output = 'STDERR'

    #### Create the ARAXMessenger
    messenger = ARAXMessenger()

    #### Test fetch_message()
    if False:
        messenger = ARAXMessenger()
        result = messenger.apply_fetch_message(messenger.message, { 'uri': 'https://arax.ncats.io/api/arax/v1.0/message/1'} )
        response.merge(result)
        if result.status != 'OK':
            print(response.show(level=ARAXResponse.DEBUG))
            return response
        message = messenger.message
        print(response.show(level=ARAXResponse.DEBUG))
        #print(json.dumps(message.to_dict(),sort_keys=True,indent=2))
        return

    #### Create an envelope in which to work
    messenger.create_envelope(response)
    if response.status != 'OK':
        print(response.show(level=ARAXResponse.DEBUG))
        return response
    message = response.envelope.message

    #### Some qnode examples
    parameters_sets = [
        { 'ids': ['DOID:9281']},
        { 'ids': ['Orphanet:673']},
        { 'name': 'acetaminophen', 'categories': ['biolink:ChemicalEntity'] },
        { 'ids': ['NCIT:C198']},
        { 'ids': ['UMLS:C4710278']},
        { 'categories': ['biolink:Protein'], 'key': 'n10'},
        { 'ids': ['UniProtKB:P14136','UniProtKB:P35579'] },
        { 'ids': ['UniProtKB:P14136','UniProtKB:P35579'], 'is_set': 'false' },
        { 'ids': ['UniProtKB:P14136'], 'is_set': 'true' },
    ]

    for parameter in parameters_sets:
        #### Add a QNode
        messenger.add_qnode(response, parameter)
        if response.status != 'OK':
            print(response.show(level=ARAXResponse.DEBUG))
            return response

    #### Some qedge examples
    parameters_sets = [
        { 'subject': 'n00', 'object': 'n01' },
        { 'subject': 'n01', 'object': 'n10', 'predicates': [ 'biolink:treats' ] },
   ]

    for parameter in parameters_sets:
        #### Add a QEdge
        messenger.add_qedge(response, parameter)
        if response.status != 'OK':
            print(response.show(level=ARAXResponse.DEBUG))
            return response

    #### Delete one of the edges
    messenger.remove_qedge(response, { 'key': 'e00' } )
    if response.status != 'OK':
        print(response.show(level=ARAXResponse.DEBUG))
        return response


    #### Show the final result
    print(response.show(level=ARAXResponse.DEBUG))
    print(json.dumps(response.envelope.to_dict(),sort_keys=True,indent=2))


if __name__ == "__main__": main()
