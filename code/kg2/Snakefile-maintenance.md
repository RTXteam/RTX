# Table of Contents

 - [Contact](#contact)
 - [Understanding Snakemake](#understanding-snakemake)
   - [`build-kg2-snakemake.sh`](#build-kg2-snakemakesh)
   - [`Snakefile`](#snakefile)
   - [Bash Shell Script to Snakemake Shell](#bash-shell-script-to-snakemake-shell)
 - [Adding to Snakemake Build System](#adding-to-snakemake-build-system)
   - [Adding an ETL Script](#adding-an-etl-script)
     - [Editing the `Snakefile`s](#editing-the-snakefiles)
       - [General Steps](#general-steps)
       - [Special Circumstances](#special-circumstances)
     - [Editing `build-kg2-snakemake.sh`](#editing-build-kg2-snakemakesh)
       - [General Steps](#general-steps-1)
   - [Adding Scripts that Go BEFORE ETL Scripts](#adding-scripts-that-go-before-etl-scripts)
     - [Editing `Snakefile-pre-etl`](#editing-snakefile-pre-etl)
       - [General Steps](#general-steps-2)
     - [Editing `build-kg2-snakemake.sh`](#editing-build-kg2-snakemakesh-1)
   - [Adding Scripts to Go AFTER Merge](#adding-scripts-that-go-after-merge)
     - [Editing `Snakefile-post-etl`](#editing-snakefile-post-etl)
       - [General Steps](#general-steps-3)
     - [Editing `Snakefile-finish`](#editing-snakefile-finish)
       - [General Steps](#general-steps-4)
     - [Editing `build-kg2-snakemake.sh`](#editing-build-kg2-snakemakesh-2)


# Contact

If you have any questions about these instructions or
the snakemake build system, please contact
Erica Wood (Crescent Valley High School) by logging a GitHub issue and assigning @ericawood or contacting them directly through email.

# Understanding Snakemake

![Overview of Snakemake Build System](https://user-images.githubusercontent.com/36611732/90065568-5a3cc980-dca1-11ea-87ea-d32f8f6b6bd8.png)

The Snakemake build system relies on two files to work:
`build-kg2-snakemake.sh` and
`Snakefile` (and its subcomponents)

## `build-kg2-snakemake.sh`

`build-kg2-snakemake.sh` runs the commands necessary for `snakemake` to run without error, in addition to running the `snakemake` command itself and defining the variables used in `Snakefile`.
These variables are passed in through the `--config` argument and accessed through the `config` dictionary in the `Snakefile` (more on this below).

**Every time a new variable is added to `build-kg2.sh`, it should be added to `build-kg2-snakemake.sh`**

The `-F` build flag **must** be left in the `snakemake` command as it ensures that every uncommented rule that connects to `Finish` (the first rule in the `Snakefile`) run, regardless of if the files generated by the rules already exist (where it would skip to the rule that generates another rule's missing `input` file), which is what happened with `-R Finish`. With `-R Finish`, the first rule to run would often be `Merge`, which re-merged files that had already been generated.

If you want to test that the `input`s and `output`s of the `Snakefile` line up, you can add the `-n` flag to your `snakemake` command to run a dry-run. However, this does not check for the accuracy of the `shell` commands.

`build-kg2-snakemake.sh` also passes into `Snakefile` the different sub-`Snakefile`s. `Snakefile-finish` (the last rule in the build process) must be listed first in the `Snakefile`. It must be added using `cat`, so that its contents are in `Snakefile` as they are in `Snakefile-finish`. The other `Snakefile-*`s can be incorporated into the `Snakefile` through an `include` statment. The order of these, with the exception of `Snakefile-finish`, does not matter as `snakemake` figures it out. All of the `Snakefile-*`s also have access to the `--config` variables.

```
cat ${CODE_DIR}/Snakefile-finish > ${CODE_DIR}/Snakefile

echo 'include: "Snakefile-pre-etl"' >> ${CODE_DIR}/Snakefile

echo 'include: "Snakefile-conversion"' >> ${CODE_DIR}/Snakefile

echo 'include: "Snakefile-post-etl"' >> ${CODE_DIR}/Snakefile

if [[ "${build_flag}" == "all" || "${build_flag}" == "alltest" ]]
then
    echo 'include: "Snakefile-semmeddb-extraction"' >> ${CODE_DIR}/Snakefile
fi

if [[ "${build_flag}" == "all" ]]
then
    echo 'include: "Snakefile-extraction"' >> ${CODE_DIR}/Snakefile
fi
```

## `Snakefile`

The `Snakefile` contains functions that enable KG2 to be built in parallel, in the form of a rule. A rule is made up of an `input`, `output`, `log` (optional), and `shell` command. Each Bash command from `build-kg2.sh` (or in a few rare instances, groups of commands) belongs to a rule.
**Snakemake determines the order of the rules and which rules can run in parallel using the `input` and `output` parameters to the rule**. If `snakemake` is run with the `-j` build flag, `snakemake` will automatically parallelize the build process using the data you've provided. First, the process(es) with no `input` run. Then, the process(es) with an `input` matching the `output` of the previous process(es) run. As many processes run at the same time as there are (1) cores for and (2) have their `input` requirements met. This results in processes that aren't dependent on each other running in parallel. **The file listed in `input` must exist for a rule to start.**
The bash command you want to run goes under the `shell` property for most commands
and the `run` property for others (when you want to run a group of commands in one rule). Below is the format of a Snakemake rule:

```
rule Rule_Name:
	input:
		input_filename_as_a_string
	output:
		output_filename_as_a_string
	log:
		log_filename_as_a_string
	shell:
		bash_command_as_a_string
```

In the past, we had all of the rules of build KG2 directly in the `Snakefile`. This was not effective, as the different build types (full, partial, test, and test including SemMedDB) each required different rules. Now, different types of rules are split into different `Snakefile`s that are all run in one central `Snakefile`.

- `Snakefile-pre-etl`: This script runs for every type of build. It includes running the verification tests and may include other processes later.
- `Snakefile-extraction`: This script only runs during full builds. This runs all of the `extract-*` scripts with the exception of `extract-semmeddb.sh` (and any others that have separate outputs depending on if the build is a test build or not)
- `Snakefile-semmeddb-extraction`: This script only runs on full or full test builds. Currently, it runs `extract-semmeddb.sh`, as this script has a separate output depending on the build type. Any future extraction scripts with this characteristic should also be put in here RATHER than in `Snakefile-extraction`
- `Snakefile-conversion`: This script runs for every type of build. It runs the scripts that convert each dataset into the KG2 JSON format.
- `Snakefile-post-etl`: This script manages everything after the databases have been converted into the KG2 JSON format until the data is ready to be compressed and uploaded to the S3 bucket.
- `Snakefile-finish`: This script contains the rule that manages the rest of the build process. This includes compressing the output files and uploading them to the S3 bucket.

## Bash Shell Script to Snakemake Shell:

For the `shell` section of a Snakemake rule, you should use Bash commands. However, there are some `snakemake` conventions that differ from Bash shell scripts. Below is how to convert them:



`build-kg2.sh` | `Snakefile` | Explanation
-- | -- | --
`${var_name}` | `config[‘VAR_NAME’]` | Variables are passed into the `Snakefile` through the `--config` argument on the command line (which for KG2 is done through `build-kg2-snakemake.sh`. In the `Snakefile`, the convention is to use uppercase variables (see [#593](https://github.com/RTXteam/RTX/issues/593#issuecomment-668746540) for more information). In addition to this, you can’t access any variable within the `Snakefile` using `${}`. You also can’t access variables in the Snakefile within the quotations (the Bash command must be a string) and must instead concatenate your command strings with your call to the `config` dictionary.
`${build_flag}` | `config['TEST_FLAG']` | The build_flag (which contains “test” or “”) is passed into the `Snakefile` as ‘TEST_FLAG’ and accessed in the `Snakefile` through `config['TEST_FLAG']`.
`${test_arg}` | `config['TEST_ARG']` | The test_arg (which contains “--test” or “”) is passed into the `Snakefile` as ‘TEST_ARG’ and accessed in the `Snakefile` through `config['TEST_ARG']`
`${test_suffix}` | `config['TEST_SUFFIX']` | The test_suffix (which contains “-test” or “”) is passed into the `Snakefile` as ‘TEST_SUFFIX’ and accessed in the `Snakefile` through `config['TEST_SUFFIX']`
`${input_file}` | `{input}` | As long as the input file is listed under `input`, you can access the input file **within** the `shell` command (inside the quotations) using `{input}`.
`${output_file}` | `{output}` | As long as the output file is listed under `output`, you can access the output file **within** the `shell` command (inside the quotations) using `{output}`.
`${log_file}` | `{log}` | As long as the log file is listed under `log`, you can access the log file **within** the `shell` command (inside the quotations) using `{log}`.


# Adding to Snakemake Build System

## Adding an ETL Script

### Editing the `Snakefile`s:

#### General Steps

(1) First, you need to add a rule to `Snakefile-extraction` (or `Snakefile-semmeddb-extraction` if there is a different output for a test build) for the extraction script (most are structured in the form 'extract-{database name}.sh').

**`input`**: the file that is created upon the successful completion of the validation tests (a placeholder located at `${BUILD_DIR}/validation-placeholder.empty` in Bash and `config['BUILD_DIR'] + "/validation-placeholder.empty"` in `snakemake`)

**`output`**: the data file that was downloaded. If there is more than one data file that was downloaded and they were put into a directory OR the data is in a mysql database, use a placeholder file instead.

**`log`**: Since script you will be running is most likely a bash script, use a log file to capture the output of `bash -x`, since it would otherwise fill the Snakemake log file in an unorganized manner that makes it difficult to read and debug issues.

**`shell`**: looks the same as it would in `build-kg2.sh`, but remember to follow the conversions listed under [Understanding Snakemake->Bash Shell Script to Snakemake Shell](#bash-shell-script-to-snakemake-shell).

Example: (no placeholder)
```
rule UniprotKB:
    input:
        config['BUILD_DIR'] + "/validation-placeholder.empty"
    output:
        config['UNIPROTKB_DAT_FILE']
    log:
        config['BUILD_DIR'] + "/extract-uniprotkb.log"
    shell:
        "bash -x " + config['CODE_DIR'] + "/extract-uniprotkb.sh {output} > {log} 2>&1"
```

Example: (placeholder) -- the key difference is that you must run `touch` to create the output file
```
rule ChemBL:
    input:
        config['BUILD_DIR'] + "/validation-placeholder.empty"
    output:
        placeholder = config['BUILD_DIR'] + "/chembl-placeholder.empty"
    log:
        config['BUILD_DIR'] + "/extract-chembl.log"
    shell:
        "bash -x " + config['CODE_DIR'] + "/extract-chembl.sh " + config['CHEMBL_MYSQL_DBNAME'] +" > {log} 2>&1 && touch {output.placeholder}"
```

(2) Then, you will need to add a rule to `Snakefile-conversion` for the conversion (which converts the data into KG2's format).

**`input`**: the output of the previous rule, whether that is a placeholder or a datafile.

**`output`**: the KG2 JSON file for that database.

**`log`**: a log file is only necessary if the script will produce a lot of print outs

**`shell`**: looks the same as it would in `build-kg2.sh`, but remember to convert to follow the conversions listed under [Understanding Snakemake->Bash Shell Script to Snakemake Shell](#bash-shell-script-to-snakemake-shell).

Example: (no placeholder - data file instead - for input)
```
rule Uniprot_Conversion:
    input:
        config['UNIPROTKB_DAT_FILE']
    output:
        config['UNIPROTKB_OUTPUT_FILE']
    shell:
        config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/uniprotkb_dat_to_json.py " + config['TEST_ARG'] + " {input} {output}"
```

Example: (placeholder for input)
```
rule ChemBL_Conversion:
    input:
        placeholder = config['BUILD_DIR'] + "/chembl-placeholder.empty"
    output:
        config['CHEMBL_OUTPUT_FILE']
    shell:
        config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/chembl_mysql_to_kg_json.py " + config['TEST_ARG'] + " " + config['MYSQL_CONF'] + " " + config['CHEMBL_MYSQL_DBNAME'] + " {output}"
```

(3) Finally, you need to merge the new KG2 JSON file into the full KG2 JSON file. This requires editing the `Merge` rule (which is in `Snakefile-post-etl`, which is the convergence point of all of the ETL rules. After this, you won't have to add any new rules as the files are already merged and everything is handled through the one, merged file.

**`input`**: You will likely notice that there are already input files present. Your job is to add a new input file to the list of input files. 

 - First, add a comma to the end of the last line in input (in the example below, `go_annotations = config['GO_ANNOTATION_OUTPUT_FILE']` would become `go_annotations = config['GO_ANNOTATION_OUTPUT_FILE'],`).

 - Then, add a new entry to the list in the form `database_name = config['DATABASE_OUTPUT_FILE']`

 - Finally, add the entry to the list of input files at the end of the `shell` command.

Example Pre-Addition:
```
rule Merge:
    input:
        owl = config['OUTPUT_FILE_FULL'],
        uniprot = config['UNIPROTKB_OUTPUT_FILE'],
        semmeddb = config['SEMMED_OUTPUT_FILE'],
        chembl = config['CHEMBL_OUTPUT_FILE'],
        ensembl = config['ENSEMBL_OUTPUT_FILE'],
        unichem = config['UNICHEM_OUTPUT_FILE'],
        ncbigene = config['NCBI_GENE_OUTPUT_FILE'],
        dgidb = config['DGIDB_OUTPUT_FILE'],
        kg_one = config['KG1_OUTPUT_FILE'],
        repoddb = config['REPODB_OUTPUT_FILE'],
        drugbank = config['DRUGBANK_OUTPUT_FILE'],
        smpdb = config['SMPDB_OUTPUT_FILE'],
        hmdb = config['HMDB_OUTPUT_FILE'],
        go_annotations = config['GO_ANNOTATION_OUTPUT_FILE']
    output:
        full = config['FINAL_OUTPUT_FILE_FULL'],
        orph = config['OUTPUT_FILE_ORPHAN_EDGES']
    shell:
        config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/merge_graphs.py " + config['TEST_ARG'] + " --kgFileOrphanEdges {output.orph} --outputFile {output.full} {input.owl} {input.uniprot} {input.semmeddb} {input.chembl} {input.ensembl} {input.unichem} {input.ncbigene} {input.dgidb} {input.kg_one} {input.repoddb} {input.drugbank} {input.smpdb} {input.hmdb} {input.go_annotations}"
```
Example Post-Addition:
```
rule Merge:
    input:
        owl = config['OUTPUT_FILE_FULL'],
        uniprot = config['UNIPROTKB_OUTPUT_FILE'],
        semmeddb = config['SEMMED_OUTPUT_FILE'],
        chembl = config['CHEMBL_OUTPUT_FILE'],
        ensembl = config['ENSEMBL_OUTPUT_FILE'],
        unichem = config['UNICHEM_OUTPUT_FILE'],
        ncbigene = config['NCBI_GENE_OUTPUT_FILE'],
        dgidb = config['DGIDB_OUTPUT_FILE'],
        kg_one = config['KG1_OUTPUT_FILE'],
        repoddb = config['REPODB_OUTPUT_FILE'],
        drugbank = config['DRUGBANK_OUTPUT_FILE'],
        smpdb = config['SMPDB_OUTPUT_FILE'],
        hmdb = config['HMDB_OUTPUT_FILE'],
        go_annotations = config['GO_ANNOTATION_OUTPUT_FILE'],
        database_name = config['DATABASE_OUTPUT_FILE']
    output:
        full = config['FINAL_OUTPUT_FILE_FULL'],
        orph = config['OUTPUT_FILE_ORPHAN_EDGES']
    shell:
        config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/merge_graphs.py " + config['TEST_ARG'] + " --kgFileOrphanEdges {output.orph} --outputFile {output.full} {input.owl} {input.uniprot} {input.semmeddb} {input.chembl} {input.ensembl} {input.unichem} {input.ncbigene} {input.dgidb} {input.kg_one} {input.repoddb} {input.drugbank} {input.smpdb} {input.hmdb} {input.go_annotations} {input.database_name}"
```

#### Special Circumstances

If you need to run multiple commands in one rule, rather than using `shell`, use `run`. When using `run`, you must specify that you are using the shell. To do this, place your bash command into the function `shell()`.

Example:
```
rule KG_One:
    input:
        config['BUILD_DIR'] + "/validation-placeholder.empty"
    output:
        config['KG1_OUTPUT_FILE']
    run:
        shell(config['S3_CP_CMD'] + " s3://rtx-kg2/" + config['RTX_CONFIG_FILE'] + " " + config['BUILD_DIR'] + "/" + config['RTX_CONFIG_FILE'])
        shell(config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/rtx_kg1_neo4j_to_kg_json.py " + config['TEST_ARG'] + " --configFile " + config['BUILD_DIR'] + "/" + config['RTX_CONFIG_FILE'] + " " + config['CURIES_TO_URLS_FILE'] + " {output}")
```

___

### Editing `build-kg2-snakemake.sh`:

#### General Steps

(1) Copy any variables managing the input and output files for that ETL script from `build-kg2.sh` into `build-kg2-snakemake.sh` and place in the appropriate location (find the last ETL filename set and put them on the next line after an empty line).

Example:
```
go_annotation_input_file=${BUILD_DIR}/goa_human.gpa
go_annotation_output_file=${BUILD_DIR}/kg2-go-annotation${test_suffix}.json
```

(2) Pass the variables into the call to `snakemake`. To do this, find an appropriate spot in the `--config` argument list (find the last ETL filename set and make a newline after it). On the newline, pass the variables in using the following format:

```
DATABASE_INPUT_FILE="${database_input_file}" DATABASE_OUTPUT_FILE="${database_output_file} \"
```

If there are additional variables that you need to pass in for that ETL script, also add them to that line. Here is a full example of the `snakemake` call (view [build-kg2-snakemake.sh](https://github.com/RTXteam/RTX/blob/master/code/kg2/build-kg2-snakemake.sh) for the latest version):

```
cd ~ && ${VENV_DIR}/bin/snakemake --snakefile ${CODE_DIR}/Snakefile \
     -F -j --config TEST_FLAG="${test_flag}" TEST_SUFFIX="${test_suffix}" \
     TEST_ARG="${test_arg}" SEMMED_TUPLELIST_FILE="${semmed_tuplelist_file}" \
     SEMMED_OUTPUT_FILE="${semmed_output_file}" UNIPROTKB_DAT_FILE="${uniprotkb_dat_file}" \
     UNIPROTKB_OUTPUT_FILE="${uniprotkb_output_file}" OUTPUT_FILE_BASE="${output_file_base}" \
     OUTPUT_FILE_FULL="${output_file_full}" OUTPUT_FILE_ORPHAN_EDGES="${output_file_orphan_edge}" \
     FINAL_OUTPUT_FILE_BASE="${final_output_file_base}" FINAL_OUTPUT_FILE_FULL="${final_output_file_full}" \
     SIMPLIFIED_OUTPUT_FILE_BASE="${simplified_output_file_base}" \
     SIMPLIFIED_OUTPUT_FILE_FULL="${simplified_output_file_full}" \
     SIMPLIFIED_OUTPUT_NODES_FILE_BASE="${simplified_output_nodes_file_base}" \
     SIMPLIFIED_OUTPUT_NODES_FILE_FULL="${simplified_output_nodes_file_full}" \
     OUTPUT_NODES_FILE_BASE="${output_nodes_file_base}" OUTPUT_NODES_FILE_FULL="${output_nodes_file_full}" \
     REPORT_FILE_BASE="${report_file_base}" REPORT_FILE_FULL="${report_file_full}" \
     SIMPLIFIED_REPORT_FILE_BASE="${simplified_report_file_base}" SIMPLIFIED_REPORT_FILE_FULL="${simplified_report_file_full}" \
     SLIM_OUTPUT_FILE_FULL="${slim_output_file_full}" ENSEMBL_SOURCE_JSON_FILE="${ensembl_source_json_file}" \
     ENSEMBL_OUTPUT_FILE="${ensembl_output_file}" CHEMBL_OUTPUT_FILE="${chembl_output_file}" \
     OWL_LOAD_INVENTORY_FILE="${owl_load_inventory_file}" CHEMBL_MYSQL_DBNAME="${chembl_mysql_dbname}" \
     UNICHEM_OUTPUT_TSV_FILE="${unichem_output_tsv_file}" UNICHEM_OUTPUT_FILE="${unichem_output_file}" \
     NCBI_GENE_TSV_FILE="${ncbi_gene_tsv_file}" NCBI_GENE_OUTPUT_FILE="${ncbi_gene_output_file}" \
     DGIDB_DIR="${dgidb_dir}" DGIDB_OUTPUT_FILE="${dgidb_output_file}" \
     REPODB_DIR="${repodb_dir}" REPODB_INPUT_FILE="${repodb_input_file}" REPODB_OUTPUT_FILE="${repodb_output_file}" \
     SMPDB_DIR="${smpdb_dir}" SMPDB_INPUT_FILE="${smpdb_input_file}" SMPDB_OUTPUT_FILE="${smpdb_output_file}" \
     DRUGBANK_INPUT_FILE="${drugbank_input_file}" DRUGBANK_OUTPUT_FILE="${drugbank_output_file}" \
     HMDB_INPUT_FILE="${hmdb_input_file}" HMDB_OUTPUT_FILE="${hmdb_output_file}" \
     GO_ANNOTATION_INPUT_FILE="${go_annotation_input_file}" GO_ANNOTATION_OUTPUT_FILE="${go_annotation_output_file}" \
     KG1_OUTPUT_FILE="${kg1_output_file}" RTX_CONFIG_FILE="${rtx_config_file}" \
     KG2_TSV_DIR="${kg2_tsv_dir}" KG2_TSV_TARBALL="${kg2_tsv_tarball}" \
     PREDICATE_MAPPING_FILE="${predicate_mapping_file}" \
     VENV_DIR="${VENV_DIR}" BUILD_DIR="${BUILD_DIR}" CODE_DIR="${CODE_DIR}" CURIES_TO_URLS_FILE="${curies_to_urls_file}" \
     MYSQL_CONF="${mysql_conf}" S3_CP_CMD="${s3_cp_cmd}" VERSION_FILE="${version_file}"
```

___

## Adding Scripts that Go **BEFORE** ETL Scripts

### Editing `Snakefile-pre-etl`:

#### General Steps

(1) Determine if your code can run in parallel with [run-validation-tests.sh](https://github.com/RTXteam/RTX/blob/master/code/kg2/run-validation-tests.sh). If it can go to 2a. If it must run after `run-validation-tests.sh`, go to 2b. If it must run before `run-validation-tests.sh`, go to 2c. 

(2a) In parallel with `run-validation-tests.sh`: you don't need an `input`, so configure the rule to have an `output`, whether a data file or a placeholder (which you will need to `touch` in your `shell` command). Use that `output` as another input for the ETL Extraction Script rules (discussed in [Adding to Snakemake Build System->Adding an ETL Script->Editing `Snakefile`->General Steps->Step 1](#general-steps)). Make sure to put a comma after the first input line. Finally, add your Bash command to the `shell` field (and a `log` file as necessary).

(2b) After `run-validation-tests.sh`: use `validation-placeholder.empty` in the `input` field of your new rule. Then, configure your new rule to have an `output` file, whether a data file or placeholder (which you will need to `touch` in your `shell` command). Then, change all of the ETL Extraction Script rules (discussed in [Adding to Snakemake Build System->Adding an ETL Script->Editing `Snakefile`->General Steps->Step 1](#general-steps)) to use this new `output` as their `input`. Finally, add your Bash command to the `shell` field (and a `log` file as necessary).

(2c) Before `run-validation-tests.sh`: you don't need an `input`, so configure the rule to have an `output`, whether a data file or a placeholder (which you will need to `touch` in your `shell` command). Use that `output` as the `input` for `rule ValidationTests`. Finally, add your Bash command to the `shell` field (and a `log` file as necessary).
___
### Editing `build-kg2-snakemake.sh`:

Follow the instructions listed under [Adding to Snakemake Build System->Adding an ETL Script->Editing `build-kg2-snakemake.sh`->General Steps](#general-steps-1).

___
## Adding Scripts that Go **AFTER** Merge

### Editing `Snakefile-post-etl`:

#### General Steps

(1) For the scripts after merge, we cannot run the build in parallel, despite the `input`/`output` allowing for it. On an r5a.8xlarge AWS instance, loading the merged KG2 JSON file into memory in Python uses approximately 70% of the memory. Thus, it cannot be loaded into two different scripts at once without running out of memory. Therefore, the first step in editing `Snakefile-post-etl` is to determine where in the build process the script should go. It will likely look similar to the order in `build-kg2.sh`.

![End of Snakemake Build System](https://user-images.githubusercontent.com/36611732/90065571-5b6df680-dca1-11ea-95fc-25ed1c5f6c4d.png)

Once you have determined where in the pipeline you would like your new rule to go, you will need to change the `input` of nearby rules. In this example, we will use the example of a rule between `Nodes` and `Simplify`.

(2) Identify the `output` of the preceding rule.

Preceding Rule:
```
rule Nodes:
    input:
        real = config['FINAL_OUTPUT_FILE_FULL'],
        placeholder = config['REPORT_FILE_FULL']
    output:
        config['OUTPUT_NODES_FILE_FULL']
    shell:
        config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/get_nodes_json_from_kg_json.py " + config['TEST_ARG'] + " {input.real} {output}"
```
In this example, the `output` of the preceding rule is `config['OUTPUT_NODES_FILE_FULL']`. This becomes the `input` for the new rule, but as the placeholder `input` rather than the actual `input` (unless it is the actual input, which means you don't need a placeholder `input`). The role of the placeholder `input` is to ensure that the build doesn't run in parallel and runs in the order that you want. The real `input` will likely be either the output file from `Merge` (`config['FINAL_OUTPUT_FILE_FULL']`) or `Simplify` (`config['SIMPLIFIED_OUTPUT_FILE_FULL']`).

(3) Write your new rule in the space after the preceding rule using information from the Understanding Snakemake section. Notice how the real `input` is the output of `Merge`. This is why, in the diagram above, there is an arrow from `Merge` to multiple later rules. It is the real `input` for multiple rules. 
```
rule New_Rule:
	input:
		real = config['FINAL_OUTPUT_FILE_FULL'],
		placeholder = config['OUTPUT_NODES_FILE_FULL']
	output:
		config['NEW_RULE_OUTPUT_FILE']
	shell:
		config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/new_rule_kg_json.py " + config['TEST_ARG'] + "{input.real} {output}"
```

(4) Edit the placeholder `input` of the rule following the new rule to match the `output` of the new rule.

Original Following Rule:
```
rule Simplify:
    input:
        real = config['FINAL_OUTPUT_FILE_FULL'],
        placeholder = config['OUTPUT_NODES_FILE_FULL']
    output:
        config['SIMPLIFIED_OUTPUT_FILE_FULL']
    log:
        config['BUILD_DIR'] + "/filter_kg_and_remap_predicates.log"
    run:
        shell("bash -x " + config['CODE_DIR'] + "/version.sh " + config['VERSION_FILE'] + " " + code['TEST_FLAG'] + " > {log} 2>&1")
        shell(config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/filter_kg_and_remap_predicates.py " + config['TEST_ARG'] + " --dropNegated --dropSelfEdgesExcept interacts_with,positively_regulates,inhibits,increase " + config['PREDICATE_MAPPING_FILE'] + " " + config['CURIES_TO_URLS_FILE'] + " {input.real} {output} " + config['VERSION_FILE'] + " >> {log} 2>&1")
```
Updated Following Rule:
```
rule Simplify:
    input:
        real = config['FINAL_OUTPUT_FILE_FULL'],
        placeholder = config['NEW_RULE_OUTPUT_FILE']
    output:
        config['SIMPLIFIED_OUTPUT_FILE_FULL']
    log:
        config['BUILD_DIR'] + "/filter_kg_and_remap_predicates.log"
    run:
        shell("bash -x " + config['CODE_DIR'] + "/version.sh " + config['VERSION_FILE'] + " " + code['TEST_FLAG'] + " > {log} 2>&1")
        shell(config['VENV_DIR'] + "/bin/python3 -u " + config['CODE_DIR'] + "/filter_kg_and_remap_predicates.py " + config['TEST_ARG'] + " --dropNegated --dropSelfEdgesExcept interacts_with,positively_regulates,inhibits,increase " + config['PREDICATE_MAPPING_FILE'] + " " + config['CURIES_TO_URLS_FILE'] + " {input.real} {output} " + config['VERSION_FILE'] + " >> {log} 2>&1")
```

### Editing `Snakefile-finish`:

#### General Steps

This is only necessary if you need to compress and upload anything new to the S3 bucket.

(1) To curb the accumulation of `shell` commands in the `Finish` rule, we put them in a separate shell script. This shell script is called `finish-snakemake.sh`. Using bash,
add your new command to `finish-snakemake.sh`.

(2) If it requires any variables that are not already being passed in (`master-config.shinc` is not sourced), add them to the list of parameters, both in documentation (the top) and
receiving (approximately the middle).

(3) If you added a parameter in step 2, add its value to the `Finish` rule in the appropriate spot.

(4) MAKE SURE THERE ARE A FEW SPARE LINES AT THE END OF `Snakefile-finish`. Since it is `cat`ted into the `Snakefile`, with includes `echo`ed in afterwards, those includes CANNOT be on the same line as the rule or they will not run and the build will fail.

___
### Editing `build-kg2-snakemake.sh`:

Follow the instructions listed under [Adding to Snakemake Build System->Adding an ETL Script->Editing `build-kg2-snakemake.sh`->General Steps](#general-steps-1).
