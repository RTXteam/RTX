# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

from openapi_server.models.base_model_ import Model
from openapi_server.models.path_constraint import PathConstraint
from openapi_server import util

from openapi_server.models.path_constraint import PathConstraint  # noqa: E501

class QPath(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, subject=None, object=None, predicates=None, constraints=None):  # noqa: E501
        """QPath - a model defined in OpenAPI

        :param subject: The subject of this QPath.  # noqa: E501
        :type subject: str
        :param object: The object of this QPath.  # noqa: E501
        :type object: str
        :param predicates: The predicates of this QPath.  # noqa: E501
        :type predicates: List[str]
        :param constraints: The constraints of this QPath.  # noqa: E501
        :type constraints: List[PathConstraint]
        """
        self.openapi_types = {
            'subject': str,
            'object': str,
            'predicates': List[str],
            'constraints': List[PathConstraint]
        }

        self.attribute_map = {
            'subject': 'subject',
            'object': 'object',
            'predicates': 'predicates',
            'constraints': 'constraints'
        }

        self._subject = subject
        self._object = object
        self._predicates = predicates
        self._constraints = constraints

    @classmethod
    def from_dict(cls, dikt) -> 'QPath':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The QPath of this QPath.  # noqa: E501
        :rtype: QPath
        """
        return util.deserialize_model(dikt, cls)

    @property
    def subject(self):
        """Gets the subject of this QPath.

        Corresponds to the map key identifier of the subject concept node for the start of the queried path.  # noqa: E501

        :return: The subject of this QPath.
        :rtype: str
        """
        return self._subject

    @subject.setter
    def subject(self, subject):
        """Sets the subject of this QPath.

        Corresponds to the map key identifier of the subject concept node for the start of the queried path.  # noqa: E501

        :param subject: The subject of this QPath.
        :type subject: str
        """
        if subject is None:
            raise ValueError("Invalid value for `subject`, must not be `None`")  # noqa: E501

        self._subject = subject

    @property
    def object(self):
        """Gets the object of this QPath.

        Corresponds to the map key identifier of the object concept node for the end of the queried path.  # noqa: E501

        :return: The object of this QPath.
        :rtype: str
        """
        return self._object

    @object.setter
    def object(self, object):
        """Sets the object of this QPath.

        Corresponds to the map key identifier of the object concept node for the end of the queried path.  # noqa: E501

        :param object: The object of this QPath.
        :type object: str
        """
        if object is None:
            raise ValueError("Invalid value for `object`, must not be `None`")  # noqa: E501

        self._object = object

    @property
    def predicates(self):
        """Gets the predicates of this QPath.

        QPath predicates are intended to convey what type of paths are desired, NOT a constraint on the types of predicates that may be in result paths. If no predicate is listed, the ARA SHOULD find paths such that the relationship represented by the path is a \"related_to\" relationship. These should be Biolink Model predicates and are allowed to be of type 'abstract' or 'mixin' (only in QGraphs!). Use of 'deprecated' predicates should be avoided.  # noqa: E501

        :return: The predicates of this QPath.
        :rtype: List[str]
        """
        return self._predicates

    @predicates.setter
    def predicates(self, predicates):
        """Sets the predicates of this QPath.

        QPath predicates are intended to convey what type of paths are desired, NOT a constraint on the types of predicates that may be in result paths. If no predicate is listed, the ARA SHOULD find paths such that the relationship represented by the path is a \"related_to\" relationship. These should be Biolink Model predicates and are allowed to be of type 'abstract' or 'mixin' (only in QGraphs!). Use of 'deprecated' predicates should be avoided.  # noqa: E501

        :param predicates: The predicates of this QPath.
        :type predicates: List[str]
        """
        if predicates is not None and len(predicates) < 1:
            raise ValueError("Invalid value for `predicates`, number of items must be greater than or equal to `1`")  # noqa: E501

        self._predicates = predicates

    @property
    def constraints(self):
        """Gets the constraints of this QPath.

        A list of constraints for the QPath. If multiple constraints are listed, it should be interpreted as an OR relationship. Each path returned is required to comply with at least one constraint.  # noqa: E501

        :return: The constraints of this QPath.
        :rtype: List[PathConstraint]
        """
        return self._constraints

    @constraints.setter
    def constraints(self, constraints):
        """Sets the constraints of this QPath.

        A list of constraints for the QPath. If multiple constraints are listed, it should be interpreted as an OR relationship. Each path returned is required to comply with at least one constraint.  # noqa: E501

        :param constraints: The constraints of this QPath.
        :type constraints: List[PathConstraint]
        """
        if constraints is not None and len(constraints) > 1:
            raise ValueError("Invalid value for `constraints`, number of items must be less than or equal to `1`")  # noqa: E501
        if constraints is not None and len(constraints) < 1:
            raise ValueError("Invalid value for `constraints`, number of items must be greater than or equal to `1`")  # noqa: E501

        self._constraints = constraints
